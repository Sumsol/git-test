# 技术复习大纲 

<!--Note-->
## 资料 

- [CS-Notes](https://cyc2018.github.io/CS-Notes/#/)
- [后端面试进阶指南](https://xiaozhuanlan.com/topic/2167809435)

## 协议

分享或者修改演绎时请保留本协议，并署名  [@CyC2018](https://dwz.cn/ZGWCOICD)。

[CC BY - Creative Commons Attribution](http://creativecommons.org/licenses/by-nc-sa/4.0)

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)
<!--/Note-->

## README

<!--Note-->
### 协议

分享或者修改演绎时请保留本协议，并署名  [@CyC2018](https://dwz.cn/ZGWCOICD)。

[CC BY - Creative Commons Attribution](http://creativecommons.org/licenses/by-nc-sa/4.0)

![](https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png)

### 目的

方便大家系统梳理知识点，并且针对每个知识点可以在本脑图中写 Markdown 笔记。

每个知识点也有相应的完成度和优先级，对于不同重要程度的知识点应该采取不同的复习方法，从而提高学习效率。

你应该把这个脑图当做最基本的复习材料，每天都要大概地过一遍，保持短期记忆，一定要知道，短期记忆对面试来说至关重要。

也可以将收集的资料整理在本脑图中，从而方便复习。

### 来源

[知识总结方法](https://xiaozhuanlan.com/topic/4150387926)

### 关于我

https://dwz.cn/ZGWCOICD

### 样式修改

百度脑图自带的样式效果不佳，建议安装以下样式脚本：[百度脑图](https://userstyles.org/styles/163774/theme)。

### 保存方法

点击左上角菜单，然后另存为“我的文档”。




<!--/Note-->

## 数据结构与算法

<!--Note-->
### 资料

- [剑指 Offer 题解](https://cyc2018.github.io/CS-Notes/#/notes/剑指%20offer%20题解)
- [Leetcode 题解](https://cyc2018.github.io/CS-Notes/#/notes/Leetcode%20题解)
- [算法](https://cyc2018.github.io/CS-Notes/#/notes/算法)
- 《算法》
- 《剑指 Offer》
- 《程序员代码面试指南》
- 《挑战程序设计竞赛》
- [Leetcode](https://leetcode.com/problemset/algorithms/)
- [玩转算法面试 从真题到思维全面提升算法思维](https://coding.imooc.com/class/82.html)
<!--/Note-->

### 算法思想

<!--Note-->
#### 数学模型

##### 1.近似

使用 ~f(N) 来表示随着N的增大除以 f(N) 的结果趋近于1的函数。例如，*N³/6-N²/2+N/3 ~ N³/6* 。

##### 2.增长数量级

将程序和它实现的算法隔离开来，这与它是由Java实现或是运行在某台计算机上无关。例如，*N³/6-N²/2+N/3* 的增长数量级为 *O(N³)* 。

##### 3.内循环

执行最频繁的指令决定了程序执行的总时间，这些指令称为程序的内循环。

##### 4.成本模型

由内循环中的操作确定，来评估算法的性质。例如，3-sum问题的成本模型是访问数组元素的次数。

#### 注意事项

##### 1.大常数

在求近似时，如果低级项中的常数系数很大，那么该近似就是错误的。

##### 2.非决定性的内循环

有些程序的内循环之外也有大量指令需要考虑。

##### 3.指令时间

计算机系统会使用**缓存**技术来组织内存，那么访问数组中不相邻元素所需的时间可能会很长。

##### 4.对最坏情况下的性能的保证

有些应用程序要求程序对于任意输入的运行时间均小于某个指定的上限。

##### 5.随机化算法

通过随机打乱输入，去除算法对输入的依赖，为性能提供保证。

##### 6.均摊分析

将所有操作的总成本除以操作总数来将成本均摊。

#### ThreeSum

ThreeSum用于统计一个数组中和为0的三元组数量。
```
public interface ThreeSum {
	int count(int[] a);
}
```

##### 1.ThreeSumSlow

内循环为`if(a[i] + a[j]+ a[k] == 0)`语句，总执行次数为 *N(N-1)(N-2) = N³/6-N²/2+N/3* ，近似为 *~N³/6* ，增长数量级为 *O(N³)* 。

```
public class ThreeSumSlow implements ThreeSum {
	@Override
	public int count(int[] a) {
		int N = a.length;
		int cnt = 0;
		for(int i = 0; i < N; i++)
			for(int j = i+1; j < N; j++)
				for(int k = j+1; k< N; k++)
					if(a[i] + a[j]+ a[k] == 0)
						cnt++;
		return cnt;
	}
```

##### 2.ThreeSumBinarySearch

将数组进行排序，对两个元素求和，并用二分查找方法查找是否存在该和的相反数，如果存在，就说明存在和为 0 的三元组。

应该注意的是，只有数组不含有相同元素才能使用这种解法，否则二分查找的结果会出错。

该方法可以将 ThreeSum 算法增长数量级降低为 *O(N²logN)*。

```
public class ThreeSumBinarySearch implements ThreeSum{
	@Override
	public int count(int[] a) {
		Arrays.sort(a);
		int N = a.length;
		int cnt = 0;
		for(int i = 0; i < N; i++)
			for(int j = i+1; j < N; j++)
				if(BinarySearch.rank(-a[i]-a[j], a) > j)
					cnt++;
		return cnt;
	}
```

```
public class BinarySearch {
	public static int rank(int key, int[] a) {
		int lo = 0, hi = a.length - 1;
		while(lo <= hi) {
			int min = lo + (hi - lo) / 2;
			if (key < a[min]) hi = min - 1;
			else if (key > a[min]) lo = min + 1;
			else return min;
		}
		return -1;
	}
}
```

##### 3.ThreeSumTwoPointer

更有效的方法是先将数组排序，然后使用双指针进行查找，时间复杂度为 *O(N²)*。

同样不适用与数组存在重复元素的情况。

```
public class ThreeSumTwoPointer implements ThreeSum {

    @Override
    public int count(int[] nums) {
        int N = nums.length;
        int cnt = 0;
        Arrays.sort(nums);
        for (int i = 0; i < N - 2; i++) {
            int l = i + 1, h = N - 1, target = -nums[i];
            while (l < h) {
                int sum = nums[l] + nums[h];
                if (sum == target) {
                    cnt++;
                    l++;
                    h--;
                } else if (sum < target) {
                    l++;
                } else {
                    h--;
                }
            }
        }
        return cnt;
    }
}
```

#### 倍率实验

如果 *T(N) ~ aNᵇlgN* ，那么 *T(2N)/T(N) ~ 2ᵇ* 。

例如对于暴力的 ThreeSum 算法，近似时间为  *~N³/6* 。进行如下实验：多次运行该算法，每次取的 N 值为前一次的两倍，统计每次执行的时间，并统计本次运行时间与前一次运行时间的比值，得到如下结果：

N	 |Time(ms)|Ratio
-----|--------|-----
500	 |48	  |/
1000 |320	  |6.7
2000 |555	  |1.7
4000 |4105	  |7.4
8000 |33575	  |8.2
16000|268909  |8.0

可以看到，`T(2*N)/T(N) ~ 2^3`，因此可以确定 `T(N) ~ a*N^3*logN`。

```
public class DoublingRatio {
	public static double timeTrial(int N) {
		int MAX = 1000000;
		int[] a = new int[N];
		for(int i = 0; i < N; i++) {
			a[i] = StdRandom.uniform(-MAX, MAX);
		}
		Stopwatch timer = new Stopwatch();
		ThreeSumBinarySearch threesum = new ThreeSumBinarySearch();
		threesum.count(a);
		return timer.elapsedTime();
	}
}
```

```
public class Stopwatch {
	private final long start;
	public Stopwatch() {
		start = System.currentTimeMillis();
	}
	public double elapsedTime() {
		long now = System.currentTimeMillis();
		return (now - start) / 1000.0;
	}
}
```





<!--/Note-->

#### 排序

<!--Note-->
##### 约定

less()方法对元素进行比较，exch()方法将元素交换位置。

排序成本模型是比较和交换的数量。

排序自己的数据类型需要实现Comparab接口，该接口要实现compareTo()方法来定义目标类型对象的自然次序。

```
public abstract class Sort<T extends Comparable<T>> {
	public abstract void sort(T[] a);
	
	protected boolean less(T v, T w) {
		return v.compareTo(w) < 0;
	}
	
	protected void exch(T[] a, int i, int j) {
		T t = a[i];
		a[i] = a[j];
		a[j] = t;
	}
	
	protected void show(T[] a) {
		for(T e : a) 
			System.out.print(e + " ");
		System.out.println();
	}
	
	protected boolean isSorted(T[] a) {
		for(int i = 1; i < a.length; i++)
			if(less(a[i], a[i-i])) return false;
		return true;
	}
}
```

##### 小结

###### 1.排序算法的比较

算法|稳定性|时间复杂度|空间复杂度|备注
:-:|:-:|:-:|:-:|:-:
选择排序|×|N²|1|运行时间与输入无关，数据移动最少|
冒泡排序|√|N²|1||
插入排序|√|N~N²|1|时间复杂度和初始顺序有关|
希尔排序|×|	N 的若干倍乘于递增序列的长度|logN|改进版插入排序|
快速排序|×|NlogN|logN|运行效率由概率提供保证|
三向切分快速排序|×|N~NlogN|logN|适用于有大量重复主键|
归并排序|√|NlogN|N||
堆排序|×|NlogN|1|无法利用局部性原理|

**快速排序是最快的通用排序算法**，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为  *~cNlogN* ，这里的 c 比其它线性对数级别的排序算法都要小。

使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。

###### 2.指针排序

我们使用的方法被称为指针排序，因为只处理元素的引用而不移动数据本身。Java中的指针操作是隐式的，除了原始数据类型之外，操作的总是数据的引用（指针），而非数据本身。

###### 3.稳定性

如果一个排序算法能够保留数组中重复元素的相对位置则被称为是稳定的。如果稳定性很重要而空间又不是问题，归并排序可能是最好的。

###### 4.将原始类型数据排序

将一大组数排序时，跳过引用可以节省存储引用所需的空间和通过引用来访问数据的成本。把Compara接口替换为原始数据类型和重定义less()方法，可以将原始类型数据更快地排序。

###### 5.Java的排序算法实现
Java主要排序方法为 java.util.Arrays.sort()。对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序，也暗示着用速度和空间（对于原始数据类型）来换取稳定性（对于引用类型）。




<!--/Note-->

##### 选择排序

<!--Note-->
###### 选择排序

每次将当前元素与自它起右侧选择最小元素进行交换。

- *~N²/2* 次比较和 *~N* 交换。

- 运行时间与输入无关。数据移动最少。对有序和乱序数组排序时间相同。

```
public class Selection<T extends Comparable<T>> extends Sort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length;
		for (int i = 0; i < N; i++) {
			int mid = i;
			for (int j = i+1; j < N; j++) 
				if (less(a[j], a[mid])) mid = j;
			exch(a, i, mid);
		}
	}
}
```
<!--/Note-->

######  

##### 冒泡排序

<!--Note-->
###### 冒泡排序

从左到右不断交换相邻逆序的元素，让未排序的最大元素上浮到右侧。

```
public class Bubble<T extends Comparable<T>> extends Sort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length;
		for (int i = N - 1; i > 0; i--)
			for (int j = 0; j < i && less(a[j+1], a[j]); j++)
				exch(a, j, j+1);
	}
}
```
<!--/Note-->

######  

##### 插入排序

<!--Note-->
###### 插入排序

每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。

- 插入排序的时间复杂度取决于数组的初始顺序：
	- 平均情况下插入排序需要 *~N²/4* 比较以及 *~N²/4* 次交换；
	- 最坏的情况是数组是倒序的,需要 *~N²/2* 比较以及 *~N²/2* 次交换；
	- 最好的情况是数组已经有序了,需要 *N-1* 次比较和 *0* 次交换。

```
public class Insertion<T extends Comparable<T>> extends Sort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length;
		for (int i = 1; i < N; i++)
			for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
				exch(a, j, j-1);
	}
}
```
<!--/Note-->

######  

##### 希尔排序

<!--Note-->
###### 希尔排序

希尔排序使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，直到 h=1。

- 希尔排序的运行时间达不到平方级别，使用递增序列 1, 4, 13, 40, ... 的希尔排序所需要的比较次数不会超过 N 的若干倍乘于递增序列的长度。

- 比前面介绍的排序快得多，而且数组越大，优势越大。但后面介绍的排序，除了对于很大的N，只会比希尔排序快两倍。

```
public class Shell<T extends Comparable<T>> extends Sort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length;
		int h = 1;
		if (h < N/3) h = 3 * h + 1; //1, 4, 13, 40, 121, 364, 1093, ...
		while (h >= 1){	
			for (int i = h; i < N; i++) {
				for (int j = i; j >= h && less(a[j], a[j-h]); j -= h) {
					exch(a, j, j-h);
				}
			}
			h = h / 3;
		}		
	}
}
```
<!--/Note-->

######  

##### 归并排序

<!--Note-->
###### 归并排序

归并排序的思想是将数组分成两部分，分别进行排序，然后归并起来。

####### 1.原地归并的抽象方法

归并方法将数组中两个已经排序的部分归并成一个。

```
public abstract class MergeSort<T extends Comparable<T>> extends Sort<T> {
	protected T[] aux;
	
	protected void merge(T[] a, int lo, int mid, int hi) {
		int i = lo, j = mid + 1;
		
		for (int k = 0; k <= hi; k++)
			aux[k] = a[k];
		
		for (int k = 0; k <= hi; k++) {
			if (i > mid) a[k] = aux[j++];
			else if (j > hi) a[k] = aux[i++];
			else if (less(aux[j], aux[i])) a[k] = aux[j++];
			else a[k] = aux[i++];
		}
	}
}
```

####### 2.自顶向下的归并排序

将一个大数组分成两个小数组去求解。

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN。

```
public class UptoDownMerge<T extends Comparable<T>> extends MergeSort<T> {
	@Override
	public void sort(T[] a) {
		aux = (T[]) new Comparable[a.length]; 
		sort(a, 0, a.length-1);
	}
	
	public void sort(T[] a, int lo, int hi) {
		if (hi <= lo) return;
		int mid = lo + (hi - lo) / 2;
		sort(a, lo, mid);
		sort(a, mid+1, hi);
		merge(a, lo, mid, hi);
	}
}
```

####### 3.自底向上的归并排序

先归并那些微型数组，然后成对归并得到的微型数组。

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN 。

```
public class DowntoUpMerge<T extends Comparable<T>> extends MergeSort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length;
		aux = (T[]) new Comparable[N];
		for(int len = 1; len < N; len *= 2) {
        	int sz = len + len; 
			for(int lo = 0; lo < N-len; lo += sz) {
				merge(a, lo, lo+len-1, Math.min(lo+sz-1, N-1));
			}
		}
	}
}
```
<!--/Note-->

###### 归并方法 

<!--Note-->
######## 1.原地归并的抽象方法

归并方法将数组中两个已经排序的部分归并成一个。

```
public abstract class MergeSort<T extends Comparable<T>> extends Sort<T> {
	protected T[] aux;
	
	protected void merge(T[] a, int lo, int mid, int hi) {
		int i = lo, j = mid + 1;
		
		for (int k = 0; k <= hi; k++)
			aux[k] = a[k];
		
		for (int k = 0; k <= hi; k++) {
			if (i > mid) {
            	a[k] = aux[j++];
			} else if (j > hi) { 
            	a[k] = aux[i++];
			} else if (less(aux[j], aux[i])) { 
            	a[k] = aux[j++];
			} else { 
            	a[k] = aux[i++];
			}
        }	
	}
}
```
<!--/Note-->

###### 自顶向下归并排序 

<!--Note-->
######## 2.自顶向下的归并排序

将一个大数组分成两个小数组去求解。

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN。

```
public class UptoDownMerge<T extends Comparable<T>> extends MergeSort<T> {
	@Override
	public void sort(T[] a) {
		aux = (T[]) new Comparable[a.length]; 
		sort(a, 0, a.length-1);
	}
	
	public void sort(T[] a, int lo, int hi) {
		if (hi <= lo) return;
		int mid = lo + (hi - lo) / 2;
		sort(a, lo, mid);
		sort(a, mid+1, hi);
		merge(a, lo, mid, hi);
	}
}
```
<!--/Note-->

###### 自底向上归并排序 

<!--Note-->
######## 3.自底向上的归并排序

先归并那些微型数组，然后成对归并得到的微型数组。

- 1/2NlgN 至 NlgN 次比较。最多访问数组 6NlgN 。

```
public class DowntoUpMerge<T extends Comparable<T>> extends MergeSort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length;
		aux = (T[]) new Comparable[N];
		for(int len = 1; len < N; len *= 2) {
        	int sz = len + len; 
			for(int lo = 0; lo < N-len; lo += sz) {
				merge(a, lo, lo+len-1, Math.min(lo+sz-1, N-1));
			}
		}
	}
}
```
<!--/Note-->

##### 快速排序

<!--Note-->
###### 快速排序

####### 1.基本排序

快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序后整个数组就有序了。

- 快速排序是原地排序（只需要一个很小的辅助栈）。

- 排序所需时间和 *NlgN* 成正比。
  -	最好情况是每次都正好将数组对半分。需要 *~NlgN* 次比较。
  - 平均需要 *~2NlnN ≈ 1.39NlgN* 次比较和 *1/6* 次交换。
  - 最坏情况下，第一次从最小元素切分，第二次从第二小元素切分，如此这般，最多需要约 *N²/2* 次比较，但**随机打乱数组能够预防这种情况**。

```
public class QuickSort<T extends Comparable<T>> extends Sort<T>{
	@Override
	public void sort(T[] a) {
		shuffle(a);
		sort(a, 0, a.length - 1);
	}
	
	private void sort(T[] a, int lo, int hi) {
		if (hi <= lo) return;
		int j = partition(a, lo, hi);
		sort(a, lo, j-1);
		sort(a, j+1, hi);
	}
	
	private void shuffle(T[] a) {
		List<Comparable> list = Arrays.asList(a);
		Collections.shuffle(list);
		list.toArray(a);
	}
	
	private int partition(T[] a, int lo, int hi) {
		int i = lo, j = hi + 1;
		T v = a[lo];
		while (true) {
			while (less(a[++i], v)) 
				if (i == hi) break;
			while (less(v, a[--j]))
				if (j == lo) break;
			if (i >= j) break;
			exch(a, i, j);
		}
		exch(a, lo, j);
		return j;
	}
}
```

####### 2.算法改进

######## 1.切换到插入排序

对于小数组，快速排序比插入排序慢，而且也会递归调用自己。因此，在排序小数组时切换到插入排序。

######## 2.三取样切分

最好情况是每次都取中位数来切分数组，但代价是需要计算中位数。将取样大小设为3并取大小居中的元素来切分数组效果最好。

######## 3.三向切分

将数组分为三部分，分别对应小于、等于和大于切分元素的数组元素。

- 对于包含**大量重复元素**的数组，它将排序时间从线性对数级降低到线性级别。
- 需要 *~(2ln2)NH* 次比较。其中 *H* 为由主键值出现频率定义的香农信息量。

######## 4.基于切分的快速选择算法

快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。

可以利用这个特性找出数组的第 k 个元素。

该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为 (N+N/2+N/4+..)，直到找到第 k 个元素，这个和显然小于 2N。

```
public class QuickSelect<T extends Comparable<T>> {
	public T select(T a[], int k) {
		int lo = 0, hi = a.length - 1;
		while (hi > 1) {
			int j = new QuickSort<T>().partition(a, lo, hi);
			System.out.println();
			if (k == j) return a[k];
			else if (k < j) 
				hi = j - 1;
			else lo = j + 1;
		}
		return a[k];
	}
}
```


<!--/Note-->

######  

###### 切分 

```
private int partition(T[] a, int lo, int hi) {
		int i = lo, j = hi + 1;
		T v = a[lo];
		while (true) {
			while (less(a[++i], v)) 
				if (i == hi) break;
			while (less(v, a[--j]))
				if (j == lo) break;
			if (i >= j) break;
			exch(a, i, j);
		}
		exch(a, lo, j);
		return j;
	}
```

##### 堆排序

###### 基于堆的优先队列

支持*删除最大元素*和*插入元素*操作的数据结构叫做优先队列。

####### 堆的定义

<!--Note-->
########## 1.堆的定义

当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。因此根结点是堆有序二叉树中的最大结点。

二叉堆简称堆，是一组能够用堆有序的完全二叉树排列的元素，并在数组中逐层存储（不使用数组第一个位置[0]）。

堆中，位置k的结点的父结点位置为k/2,两个子结点的位置分别为2k和2k+1。

- 堆中最长路径为 *~lgN* ，因此优先队列所需比较次数和 *logN* 成正比。

```
public class Heap<T extends Comparable<T>>{
	private T[] heap;
	private int N = 0;
	
	public Heap(int maxN){
		heap = (T[]) new Comparable[maxN + 1];
	}
	
	public boolean isEmpty() {
		return N == 0;
	}
	
	public int size() {
		return N;
	}
	
	private boolean less(int i, int j) {
		return heap[i].compareTo(heap[j]) < 0;
	}
	
	private void swap(int i, int j) {
		T t = heap[i];
		heap[i] = heap[j];
		heap[j] = t;
	}
}
```
<!--/Note-->

####### 上浮

<!--Note-->
########## 2.上浮

在堆中，当一个结点比父结点大，那么需要交换这个两个结点。交换后还可能比它新的父结点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。

```
private void swim(int k) {
	while (k > 1 && less(k/2, k)) {
		swap(k/2, k);
		k = k/2;
	}
}
```
<!--/Note-->

####### 下沉

<!--Note-->
########## 3.下沉

在堆中，当一个结点比子结点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个结点如果有两个子结点，应当与两个子结点中最大那个结点进行交换。

```
private void sink(int k) {
	while (2*k <= N) {
		int j = 2*k;
		if (j < N && less(j, j+1)) 
			j++;
		if (!less(k, j)) break;
		swap(k, j);
		k = j;
	}
}
```
<!--/Note-->

####### 插入元素

<!--Note-->
########## 4.插入元素

将新元素放到数组末尾，然后上浮到合适的位置。

- 插入元素操作只需不超过 *(lgN+1)* 次比较。

```
public void insert(T v) {
	heap[++N] = v;
	swim(N);
}
```

<!--/Note-->

####### 删除最大元素

<!--Note-->
########## 5.删除最大元素

从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。

- 删除最大元素操作需要不超过 *(2lgN)* 次比较。

```
public T delMax() {
	T max = heap[1];
	swap(1, N--);
	heap[N+1] = null;
	sink(1);
	return max;
}
```
<!--/Note-->

###### 堆排序

<!--Note-->
######## 堆排序

把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。

######### 1.堆的构造

无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作。叶子结点不需要进行下沉操作，可以忽略叶子结点的元素，因此只需要遍历一半的元素即可。

######### 2.下沉排序

将堆中的最大元素删除，然后放入对缩小后数组空出的位置。


- 堆排序只需要至少 *(2NlgN+2N)* 次比较（以及一半次数的交换）。

- 现代操作系统很少使用堆排序，因为它无法利用局部性原理进行缓存，也就是数组元素很少和相邻的元素进行比较和交换。


```
 /**
     * 数组第 0 个位置不能有元素
     */
public class HeapSort<T extends Comparable<T>> extends Sort<T> {
	@Override
	public void sort(T[] a) {
		int N = a.length - 1;
		for (int k = N / 2; k >= 1; k--)
			sink(a, k, N);
		while(N > 1) {
			exch(a, 1, N--);
			sink(a, 1, N);
		}
	}
	
	private void sink(T[] a, int k, int N) {
		while (2 * k <= N) {
			int j = 2 * k;
			if (j < N && less(a, j, j+1)) j++;
			if (!less(a, k, j)) break;
			exch(a, k, j);
			k = j;
		}
	}
	
	private boolean less(T[] a, int i, int j) {
		return a[i].compareTo(a[j]) < 0;
	}
}

```
<!--/Note-->

#######  

#### 栈和队列

##### 栈

<!--Note-->
###### 栈

```
public interface Stack<Item> extends Iterable<Item> {
	boolean isEmpty();
	int size();
	Stack<Item> push(Item item);
	Item pop() throws Exception;
}
```

####### 1.数组实现

```
public class ResizingArrayStack<Item> implements Stack<Item> {
	private Item[] a = (Item[]) new Object[1];
	private int N = 0;
	
	@Override
	public boolean isEmpty() {
		return N == 0;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	private void resize(int max) {
		Item[] temp = (Item[]) new Object[max];
		for(int i = 0; i < N; i++) {
			temp[i] = a[i];
		}
		a = temp;
	}
	
	@Override
	public Stack<Item> push(Item item) {
		if (N == a.length) resize(2*N);
		a[N++] = item;
		return this;
	}
	
	@Override
	public Item pop() throws Exception {
		if (isEmpty())
			throw new Exception("Stack is empty!");
		Item item = a[--N];
		a[N] = null; // 避免对象游离
		if (N > 0 && N == a.length/4)
			resize(a.length/2);
		return item;
	}
	
	@Override
	public Iterator<Item> iterator(){
		// 返回逆序遍历的迭代器
		return new Iterator<Item>() {
			private int i = N;
			
			public boolean hasNext() {
				return i > 0;
			}
			
			public Item next() {
				return a[--i];
			}
			
			public void remove() {}
		};
	}
}
```

####### 2.链表实现

```
public class ListStack<Item> implements Stack<Item> {
	private Node top = null;
	private int N = 0;
	private class Node{
		Item item;
		Node next;
	}
	
	@Override
	public boolean isEmpty() {
		return top == null;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	@Override
	public Stack<Item> push(Item item) {
		Node newTop = new Node();
		newTop.item = item;
		newTop.next = top;
		top = newTop;
		N++;
		
		return this;
	}
	
	@Override
	public Item pop() throws Exception {
		if (isEmpty())
			throw new Exception("Stack is empty!");
		
		Item item = top.item;
		top = top.next;
		N--;
		
		return item;
	}
	
	@Override
	public Iterator<Item> iterator() {
		return new Iterator<Item>() {
			// 返回链表遍历的迭代器
			private Node current = top;
			
			public boolean hasNext() {
				return current != null; // current.next != null; 错误
			}
			
			public Item next() {
				Item item = current.item;
				current = current.next;
				return item;
			}
	        
			public void remove() {}
		};
	}
}
```





<!--/Note-->

##### 队列

<!--Note-->
###### 队列

```
public interface Queue<Item> extends Iterable<Item> {
	boolean isEmpty();
	int size();
	Queue<Item> enqueue(Item item);
	Item dequeue() throws Exception;
}
```

```
public class ListQueue<Item> implements Queue<Item> {
	private Node first;
	private Node last;
	private int N = 0;
	private class Node {
		Item item;
		Node next;
	}
	
	@Override
	public boolean isEmpty() {
		return first == null;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	@Override
	public Queue<Item> enqueue(Item item){
		Node newNode = new Node();
		newNode.item = item;
		newNode.next = null;
		if (isEmpty()) 
			first = newNode;
		else
			last.next = newNode;
		last = newNode;
		return this;
	}
	
	@Override
	public Item dequeue() throws Exception {
		if (isEmpty())
			throw new Exception("Queue is empty!");
		
		Item item = first.item;
		first = first.next;
		if (isEmpty())
			last = null;
		N--;
		return item;
	}
	
	@Override
	public Iterator<Item> iterator(){
		return new Iterator<Item>() {
			private Node current = first;
			
			public boolean hasNext() {
				return current != null;
			}
			
			public Item next() {
				Item item = current.item;
				current = current.next;
				return item;
			}
			
			public void remove() {}
		};
	}
}
```
<!--/Note-->

#### 查找

<!--Note-->
###### 符号表实现的成本总结

算法（数据结构）|查找|插入|是否支持有序操作
 -|-|-|-
 顺序查找（无序链表）|N|N|否
 二分查找（有序数组）|logN|N|是
 二叉树查找（BST）|logN|logN|是
 2-3树查找（红黑树）|logN|logN|是
 拉链法（链表数组）|N/M|N/M|否
 线性探测法（并行数组）|1|1|否
 
- 散列表代码更简单，查找时间最优；二叉查找树抽象结构更简单，红黑树支持的操作更多。 
- *根据经验法则，优先选择散列表，当需要有序性操作时才选择红黑树。*

###### Java的符号表实现

java.util.TreeMap：红黑树
java.util.HashMap：拉链法的散列表

-
<!--/Note-->

##### 简单符号表

<!--Note-->
###### 符号表(Symbol Table)

符号表存储键值对的数据结构，支持两种操作：插入（put）即将一组新的键值对存入表中；查找（get），即根据给定的键得到相应的值。

符号表分为有序和无序两种，有序符号表主要指支持 min()、max() 等根据键的大小关系来实现的操作。有序符号表的键需要实现 Comparable 接口。

```
public interface UnorderST<Key, Value> {
	void put(Key key, Value val);
	Value get(Key key);
	void delete(Key key);
	int size();
	//Iterable<Key> keys();
}
```

```
public interface OrderST<Key extends Comparable<Key>, Value> {
	void put(Key key, Value val);
	Value get(Key key);
	int size();
	int rank(Key key);
	Key min();
	Key max();
	Key select(int k);
	Key ceiling(Key key);
	Key floor(Key key);
	void delete(Key key);
	Iterable<Key> keys(Key lo, Key hi);  
}
```


 
 
 
 
<!--/Note-->

###### 无序链表中的顺序查找

<!--Note-->
####### 无序链表中的顺序查找

- 未命中的查找和插入操作都需要N次比较。命中的查找在最坏情况下需要N次比较。

```
public class SequentialSearchST<Key, Value> implements UnorderST<Key, Value> {
	private Node first;
	
	private class Node{
		Key key;
		Value val;
		Node next;
		
		public Node(Key key, Value val, Node next) {
			this.key = key;
			this.val = val;
			this.next = next;
		}
	}
	
	@Override
	public void put(Key key, Value val) {
		for (Node x = first; x != null; x = x.next) {
			if (key.equals(x.key)) {
				x.val = val;
				return;
			}	
		}
		first = new Node(key, val, first);
	}
	
	@Override
	public Value get(Key key) {
		for (Node x = first; x != null; x = x.next) {
			if (key.equals(x.key))
				return x.val;
		}
		return null;
	}
	
	@Override
	public int size() {
		int cnt = 0;
		for (Node x = first; x != null; x = x.next) 
			cnt++;
		return cnt;
	}
	
	@Override
	public void delete(Key key) {
		Node pre = first;
		for (Node x = first; x != null; x = x.next) {
			if (key.equals(x.key)) {
				pre.next = x.next;
				return;
			}
			pre = x;
		}
	}
}
```
<!--/Note-->

#######  

###### 有序数组中的二分查找

<!--Note-->
####### 有序数组中的二分查找

使用一对平行数组，一个存储键一个存储值。

二分查找的 rank() 方法至关重要，当键在表中时，返回该键的位置，即表中小于它的键的数量；当键不在表中时，还是返回表中小于它的键的数量（*rank()实际返回的就是向上取整的下标*）。

- 二分查找最多需要 *（logN+1）* 比较。有序数组中插入一个新元素在最坏情况下需要访问 *~2N* 次数组。

```
public class BinarySearchST<Key extends Comparable<Key>, Value> implements OrderST<Key, Value> {
	private Key[] keys;
	private Value[] vals;
	private int N;
	
	public BinarySearchST(int capacity) {
		keys = (Key[]) new Comparable[capacity];
		vals = (Value[]) new Object[capacity]; 
	}
	
	@Override
	public int rank(Key key) {
		// 找出小于指定键的键的数量
		int lo = 0, hi = N - 1;
		while (lo <= hi) {
			int mid = lo + (hi - lo) / 2;
			int cmp = key.compareTo(keys[mid]);
			if (cmp > 0)
				lo = mid + 1;
			else if (cmp < 0)
				hi = mid - 1;
			else 
				return mid;
		}
		return lo;
	}
	
	@Override
	public void put(Key key, Value val) {
		int i = rank(key);
		// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value
		if (i < N && key.compareTo(keys[i]) == 0) {
			vals[i] = val;
			return;
		}
		// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置
		for (int j = N; j > i; j--) {
			keys[j] = keys[j-1];
			vals[j] = vals[j-1];
		}
		keys[i] = key;
		vals[i] = val;
		N++;
	}
	
	@Override
	public Value get(Key key) {
		int i = rank(key);
		if (i < N && key.compareTo(keys[i]) == 0) 
			return vals[i];
		else 
			return null;
	}
	
	@Override
	public int size() {
		return N;
	}
	
	@Override
	public Key min() {
		return keys[0];
	}
	
	@Override
	public Key max() {
		return keys[N-1];
	}
	
	@Override 
	public Key select(int k) {
		return keys[k];
	}
	
	@Override
	public Key ceiling(Key key) {
		//向上取整
		return keys[rank(key)];
	}
	
	@Override
	public Key floor(Key key) {
		//向下取整
		int i = rank(key);
		if (i < N && key.compareTo(keys[i]) == 0)
			return keys[i];
		else
			return keys[i-1];
	}
	
	@Override
	public void delete(Key key) {
		int i = rank(key);
		if (i < N && key.compareTo(keys[i]) == 0) {
			for (int j = i; j < N - 1; j++) {
				keys[j] = keys[j+1];
				vals[j] = vals[j+1];
			}
			keys[N-1] = null;
			vals[N-1] = null;
			N--;
		}
	}
	
	@Override
	public Iterable<Key> keys(Key lo, Key hi){
		Queue<Key> q = new ListQueue<Key>();
		for (int i = rank(lo); i < rank(hi); i++) 
			q.enqueue(keys[i]);
		if (hi.compareTo(keys[rank(hi)]) == 0)
			q.enqueue(hi);
		return q;
	}
}
```
<!--/Note-->

#######  

##### 二叉查找树

二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。

BST 有一个重要性质，就是它的中序遍历结果递增排序。

基于二叉查找树的符号表：

```
public class BST<Key extends Comparable<Key>, Value> implements OrderST<Key, Value> {
	private Node root;
	
	private class Node{
		Key key;
		Value val;
		Node left, right;
		int N;
		
		Node(Key key, Value val, int N){
			this.key = key;
			this.val = val;
			this.N = N;
		}
	}
	
	@Override
	public int size() {
		return size(root);
	}
	
	private int size(Node x) {
		if (x == null) return 0;
		else return x.N;
	}
}
```

###### 查找

- 如果树是空的，则查找未命中；
- 如果被查找的键和根节点的键相等，查找命中；
- 否则递归地在适当的子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。

```

	@Override
	public Value get(Key key) {
		return get(root, key);
	}
	
	private Value get(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp < 0) return get(x.left, key);
		else if (cmp > 0) return get(x.right, key);
		else return x.val;
	}
```

###### 插入

- 如果树是空的，返回一个含有该键值对的新结点；
- 如果被查找的键小于根结点的键，在左子树中插入该键，否则在右子树中插入该键；
- 递归：沿搜索路径向上更新链接并增加结点计数器的值。

```

	@Override
	public void put(Key key, Value val) {
		root = put(root, key, val);
	}
	
	private Node put(Node x, Key key, Value val) {
		if (x == null) return new Node(key, val, 1);
		int cmp = key.compareTo(x.key);
		if (cmp < 0) x.left = put(x.left, key, val);
		else if (cmp > 0) x.right = put(x.right, key, val);
		else x.val = val;
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
```

###### 最大键和最小键

- 如果根结点的左链接为空，那么树中最小键就是根结点；
- 如果左链接非空，那么树中最小键就是左子树中的最小键。

```

    @Override
	public Key min() {
		return min(root).key;
	}
	
	private Node min(Node x) {
		if (x.left == null) return x;
		return min(x.left);
	}
	
	@Override
	public Key max() {
		return max(root).key;
	}
	
	private Node max(Node x) {
		if (x.right == null) return x;
		return max(x.right);
	}
```

###### 向上取整和向下取整

<!--Note-->
######### `floor(key)`：小于等于键的最大键。

- 如果键小于根结点的键，那么floor(key)一定在左子树中；
- 如果键大于根结点的键，那么只要右子树中存在floor(key)则返回，否则根结点为floor(key)。

```

	@Override
	public Key floor(Key key) {
		Node x = floor(root, key);
		if (x == null) return null;
		else return x.key;
	}
	
	private Node floor(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp == 0) return x;
		else if (cmp < 0) return floor(x.left, key);
		else {
        Node t = floor(x.right, key);
		return t != null ? t : x;
        }
	}
	
	@Override
	public Key ceiling(Key key) {
		Node x = ceiling(root, key);
		if (x == null) return null;
		return x.key;
	}
	
	private Node ceiling(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp == 0) return x;
		else if (cmp > 0) ceiling(x.right, key);
		else {
        Node t = ceiling(x.left, key);
		return t != null ? t : x;
        }
	}
```
<!--/Note-->

###### 选择和排名

<!--Note-->
######### `select(k)`：返回排名为k的键。

- 如果左子树结点数t大于k，在左子树中查找排名为k的键；
- 如果t等于k，返回根结点的键；
- 如果t小于k，在右子树中查找排名为(k-t-1)的键。

```
	
    @Override
	public Key select(int k) {
		return select(root, k).key;
	}
    
	private Node select(Node x, int k) {
		if (x == null) return null;
		int t = size(x.left);
		if (t > k) return select(x.left, k);
		else if (t < k) return select(x.right, k-t-1);
		else return x;
	}
```

######### `rank(key)`：返回key的排名。

- 如果键等于根结点的键，返回左子树的结点数；
- 如果键小于根结点的键，返回键在左子树中的排名；
- 如果键大于根结点的键，返回左子树结点数加上1（根结点）加上键在右子树中的排名。

```

	@Override
	public int rank(Key key) {
		return rank(root, key);
	}
    
	private int rank(Node x, Key key) {
		if (x == null) return 0;
		int cmp = key.compareTo(x.key);
		if (cmp < 0) return rank(x.left, key);
		else if (cmp > 0) return 1 + size(x.left) + rank(x.right, key);
		else return size(x.left);
	}
```


<!--/Note-->

###### 删除

<!--Note-->
######### `deleteMin()`：删除最小键。

- 不断深入根结点的左子树中直至遇见空链接，将指向该结点的链接指向该结点的右子树。

```

	public void deleteMin() {
		root = deleteMin(root);
	}
    
	private Node deleteMin(Node x) {
		if (x.left == null) return x.right;
		x.left = deleteMin(x.left);
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
```

######### `delete(key)`：删除键为key的结点。

- 如果待删除的结点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可；
- 否则，让右子树的最小结点替换该结点。

```

	@Override
	public void delete(Key key) {
		root = delete(root, key);
	}
    
	private Node delete(Node x, Key key) {
		if (x == null) return null;
		int cmp = key.compareTo(x.key);
		if (cmp < 0) x.left = delete(x.left, key);
		else if (cmp > 0) x.right = delete(x.right, key);
		else {
			if (x.left == null) return x.right;
			if (x.right == null) return x.left;
			Node t = x;
			x = min(x.right);
			x.left = t.left;
			x.right = deleteMin(t.right);
		}
		x.N = size(x.left) + size(x.right) + 1;
		return x;
	}
```
<!--/Note-->

####### 删除最小键

####### 删除操作

###### 范围查找

<!--Note-->
######### `keys(lo, hi)`：返回给定范围内的键。

- 利用二叉查找树**中序遍历**的结果为递增的特点。

```

	@Override
	public Iterable<Key> keys(Key lo, Key hi) {
		return keys(root, lo, hi);
	}
	public Queue<Key> keys(Node x, Key lo, Key hi){
		Queue<Key> queue = new LinkedList();
		keys(x, queue, lo, hi);
		return queue;
	}
	private void keys(Node x, Queue<Key> queue, Key lo, Key hi){
		if (x == null) return;
		int cmplo = lo.compareTo(x.key);
		int cmphi = hi.compareTo(x.key);
		if (cmplo < 0) keys(x.left, queue, lo, hi);
		if (cmplo <= 0 && cmphi >= 0) queue.add(x.key);
		if (cmphi > 0) keys(x.right, queue, lo, hi);
	}
```
<!--/Note-->

###### 分析

二叉查找树的算法运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。

- 最好的情况下树是完全平衡的，每条空链接和根节点的距离都为 *logN* 。

- 在最坏的情况下树是斜树，树的高度为 *N* 。

- 二叉查找树所有操作在最坏情况下所需的时间都和树的高度成正比。

####### 完全二叉树

####### 斜树

##### 红黑树

<!--Note-->
###### 回答

- JDK 中 TreeMap 和 TreeSet，1.8 之后的 HashMap 和 ConcurrentHashMap
- 介绍二叉查找树、23查找树，再介绍红黑树原理
- 与 B+ 树进行比较

###### 资料

- [红黑树 - 维基百科](https://zh.wikipedia.org/zh-hans/%E7%BA%A2%E9%BB%91%E6%A0%91)
<!--/Note-->

###### 2-3查找树

####### 引入2- 节点和3- 节点

########  

####### 插入操作

######## 2- 节点

#########  

######## 3- 节点

#########  

####### 高度不超logN

###### 红黑二叉查找树

####### 红链接为左链接，完美黑色平衡

######## 

####### 左旋转

########  

####### 右旋转

########  

####### 颜色转换

########  

####### 插入

########  

####### 高度不超2logN

##### B+ 树

- 大规模数据存储中，实现索引查询这样一个实际背景下，**磁盘查找存取的次数往往由树的高度所决定**，二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率。

- B树与红黑树最大的不同在于，B树的结点可以有许多孩子，从几个到几千个。B树与红黑树很相似，一棵含n个结点的B树的高度也为O（logn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。


[从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)





###### B树

<!--Note-->
######## B树
B树（B-tree）是一种平衡的多路查找树，结点最大的孩子数目称为B树的阶。
一个m阶的B树具有如下属性：
- 如果根结点不是叶结点，则其至少有两个孩子（子树）。
- 每个非根的分支结点都有k-1个元素和k个孩子，每个叶子结点n都有k-1个元素，其中⌈m/2⌉<=k<= m。
- 所有叶子结点都位于同一层次。
- 所有分支结点包含下列信息数据（n,A₀,K₁,A₁,K₂,A₂,...,Kₙ,Aₙ），其中：
	- Kᵢ(i=1,2,...,n)为关键字，且Kᵢ<Kᵢ₊₁;
    - Aᵢ(i=0,2,...,n)为指向子树根结点的指针，且指针Aᵢ所指子树中所有结点的关键字均小于Kᵢ₊₁，但都大于Kᵢ;
    - 关键字的个数必须满足：n(⌈m/2⌉-1<=n<= m-1)。

对于n个关键字的m阶B树，树的高度*h<= log⌈m/2⌉((n+1)/2)+1*。
<!--/Note-->

####### 图为3阶B树，结点结构为（2,A₀,K₁,A₁,K₂,A₂） 

###### B+树

<!--Note-->
######## B+树
一个m阶的B+树和m阶的B树的差异在于：
- 有n棵子树的结点中包含n个关键字；
- 所有的叶子结点包含全部关键字的信息，及指向含有这些关键字记录的指针，叶子结点本身依关键字的大小自小到大顺序链接；
- 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。

B+树相较于B树的优点：
- **B+-tree的磁盘读写代价更低**：B+-tree的内部结点并没有指向关键字具体信息的指针。
- **B+-tree的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路，导致每一个数据的查询效率相当。
<!--/Note-->

#######  

##### LSM

##### AVL

平衡二叉树（AVL树）是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。



##### 散列表（哈希表）

散列表类似于数组，可以把散列值看成数组的索引值。

- 使用散列的查找算法分为两步：
	- 1、用散列函数将被查找的键转化为数组的一个索引。
	- 2、处理碰撞冲突。

- 访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作。

- 由于无法通过散列值知道键的大小关系，因此散列表**无法实现有序性操作**。

###### 散列函数

对于一个大小为 M 的散列表，散列函数能够把任意键转换为 [0, M-1] 内的正整数，该正整数即为 hash 值。

- 散列函数应满足三个条件：
	- 一致性——等价的键必然产生相等的散列值；
	- 高效性——计算简便。
	- 均匀性——均匀地散列所有的键。

### 键的类型
对于每种类型的键都需要一个与之对应的散列函数：
- **正整数**：使用除留余数法，选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数。`k%M`能够有效地将键散布在[0, M-1]之间。
- **浮点数**：将键表示为二进制数后使用除留余数法。
- **字符串**：将字符串当作一个N位的R进制值，并将它除以M并取余。R通常取31。
```
int hash = 0;
for (int i = 0; i < s.length(); i++)
	hash = (R * hash + s.charAt(i)) % M;
```
- **组合键**：如果键的类型含有多个整型变量。如
`int hash = (((day * R + month) % M) * R + year) % M;`

### Java的约定
Java令所有数据类型都继承一个能够返回一个32位整数的hashCode()。

如果两个对象的hashCode()方法的返回值相同，这两个对象可能不同，还需用equals()进行判断。

**hashCode()和除留余数法结合返回一个数组索引**。将符号位屏蔽（将一个32位整数变成一个31位非负整数），然后用除留余数法得到一个[0, M-1]之间的整数：
```
private int hash(Key x)
{	return (x.hashCode() & 0x7fffffff) % M;}
```

### 自定义的hashCode()方法
hashCode()方法能够将键平均地散布为所有可能的32位整数。对于任意对象x，可调用x.hashCode()得到一个32位整数值。例如：
```
public class Transaction {

    private final String who;
    private final Date when;
    private final double amount;

    public int hashCode() {
        int hash = 17;
        int R = 31;
        hash = R * hash + who.hashCode();
        hash = R * hash + when.hashCode();
        hash = R * hash + ((Double) amount).hashCode();
        return hash;
    }
}
```

### 软缓存
如果散列值的计算很耗时，可以将每个键的散列值缓存起来，即每个键用一个hash变量来保存hashCode()的返回值。



####### 散列表大小M最好取素数

######## 若M=4，hash为2的数都能被2整除，存在联系。

####### R为何取31

######## 移位和减法取代乘法，获取更好性能：31 * i == (i << 5) - i

####### hashCode()默认取对象内存地址

###### 拉链法

拉链法使用链表来存储 hash 值相同的键，从而解决冲突。

查找需要分两步，首先查找 Key 所在的链表，然后在链表中顺序查找。

- 对于 N 个键，M 条链表 (N>M)，如果哈希函数能够满足均匀性的条件，每条链表的大小趋向于 N/M，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。

```
public class SeparateChainingHashST<Key, Value> {
    private int N;
    private int M;
    private SequentialSearchST<Key, Value>[] st;

    public SeparateChainingHashST() {
        this(997);
    }

    public SeparateChainingHashST(int M) {
        this.M = M;
        st = (SequentialSearchST<Key, Value>[]) new SequentialSearchST[M];
        for (int i = 0; i < M; i++)
            st[i] = new SequentialSearchST<>();
    }

    private int hash(Key key){
        return (key.hashCode() & 0x7fffffff) % M;
    }

    private Value get(Key key){
        return (Value) st[hash(key)].get(key);
    }

    private void put(Key key, Value val){
        st[hash(key)].put(key, val);
    }
}	
```

#######  

###### 线性探测法

线性探测法使用空位来解决冲突，当冲突发生时，向前探测一个空位来存储冲突的键。

- 使用线性探测法，数组的大小 M 应当大于键的个数 N（M>N)。
- α = N/M，把 α 称为使用率。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 α 在 [1/4, 1/2] 之间。


```
public class LinearProbingHashST<Key, Value> {
    private int N;
    private int M;
    private Key[] keys;
    private Value[] vals;

    public LinearProbingHashST(){
        this(16);
    }
     public LinearProbingHashST(int capacity){
        M = capacity;
        N = 0;
        keys = (Key[]) new Object[M];
        vals = (Value[]) new Object[M];
     }

    private int hash(Key key){
        return (key.hashCode() & 0x7fffffff) % M;
    }

    private void resize(int cap){
        LinearProbingHashST<Key, Value> t;
        t = new LinearProbingHashST<>(cap);
        for (int i = 0; i < M; i++) {
            if (keys[i] != null)
                t.put(keys[i], vals[i]);
        }
        this.keys = t.keys;
        this.vals = t.vals;
        this.M = t.M;
    }

    public void put(Key key, Value val){
        if (N >= M/2) resize(2 * M);

        int i;
        for (i = hash(key); keys[i] != null; i = (i + 1) % M){
            if (keys[i].equals(key)){
                vals[i] = val;
                return;
            }
        }
        keys[i] = key;
        vals[i] = val;
        N++;
    }

    public Value get(Key key){
        for(int i = hash(key); keys[i] != null; i = (i + 1) % M){
            if (keys[i].equals(key))
                return vals[i];
        }
        return null;
    }

    public void delete(Key key){
        if (key == null) throw new IllegalArgumentException("argument to delete() is null");
        int i = hash(key);
        while (!keys[i].equals(key))
            i = (i + 1) % M;
        keys[i] = null;
        vals[i] = null;
        
        // 将之后相连的键值对重新插入
        i = (i + 1) % M;
        while (keys[i] != null){
            Key keyToRedo = keys[i];
            Value valToRedo = vals[i];
            keys[i] = null;
            vals[i] = null;
            N--;
            put(keyToRedo, valToRedo);
            i = (i + 1) % M;
        }
        N--;
        if (N > 0 && N <= M/8) resize(M/2);
    }
}

```

#######  

#### 字符串

##### 指纹

##### KMP

###### 字符串匹配 

```
int match(String s, String pattern) {
	int i = 0, j = 0;
	int slen = s.length(), plen = p.length();

	while (i < slen && j < plen) {
		if (s.charAt(i) == p.charAt(j)) {
			i++; j++;
		} else {
			// 不匹配时
			// ...（暴力或KMP）
        }
	}
    
    if (j == plen) {
		return i - j;
	} else {
    	return -1;
    }	
}
``````

####### 暴力匹配算法

```
int match(String s, String pattern) {
	int i = 0, j = 0;
	int slen = s.length(), plen = p.length();

	while (i < slen && j < plen) {
		if (s.charAt(i) == p.charAt(j)) {
			i++; j++;
		} else {
			// 不匹配时
            i = i - j + 1;
            j = 0;
        }
	}
    
    if (j == plen) {
		return i - j;
	} else {
    	return -1;
    }	
}
```

####### KMP算法

```
public int kmp(String s, String p) {
    int i = 0, j = 0;
    int slen = s.length(), plen = p.length();

    int[] next = new int[plen];
    getNext(p, next);

    while (i < slen && j < plen) {
        if (s.charAt(i) == p.charAt(j)) {
            i++;
            j++;
        } else {
        	// 不匹配时
            if (next[j] == -1) {
            	// 跟p的第一个字符不匹配
                i++;
            } else {
                j = next[j];
            }
        }
    }

    if (j == plen) {
        return i - j;
    } else {
        return -1;
    }
}
```

        	 





######## 部分匹配值

```
public void getNext(String p, int[] next) {
    int j = 1, k = 0;
    next[0] = -1;
    int len = p.length();

    while (i < len - 1) {
        if (p.charAt(j) == p.charAt(k)) {
            j++;
            k++;
            next[j] = k;
        } else {
            if (next[k] == -1) {
                i++;
                next[j] = 0;
            } else {
                k = next[k];
            }
        }
    }
}
```
```

i BBC ABCDAB ABCDABCDABDE 
j     ABCDABD
k         ABCDABD 
next -1000012
```

##### AC 自动机

##### 排序

##### Trie

<!--Note-->
####### 单词查找树（Trie）

*Trie的核心思想是空间换时间。*

- 假设字符的种数有m个，有若干个长度为n的字符串构成了一个Trie树，则每个节点的出度为m（即每个节点的可能子节点数量为m），Trie树的高度为n；
- Trie树的最坏空间复杂度为 *O(mⁿ)*；
- Trie树的最坏时间复杂度为 *O(n)*。

```
public class TrieST<Value> implements UnorderST<String, Value> { //String替代泛型Key
    private static int R = 256;
    private Node root;

    private static class Node{
        private Object val; //内部静态类无法引用外部类中Value
        private Node[] next = new Node[R]; //但可引用外部类中的静态成员
    }
}
```
<!--/Note-->

###### 查找

- 键的尾字符所对应的结点中的值非空。命中
- 键的尾字符所对应的结点中的值为空。未命中
- 查找结束于一条空链接。未命中

```
@Override
    public Value get(String key){
        Node x = get(root, key, 0);
        if (x == null)
            return null;
        return (Value) x.val;
    }
    private Node get(Node x, String key, int d){
        if (x == null)
            return null;
        if (d == key.length())
            return x;
        char c = key.charAt(d);
        return get(x.next[c], key, d+1);
    }
```

###### 插入

- 在到达键的尾字符之前就遇到了一个空链接。为键中还未被检查的每个字符创建一个对应结点并将键的值保存到最后一个字符的结点中。
- 在遇到空链接之前就到达了键的尾字符。将该结点的值设为键所对应的值。

```
@Override
    public void put(String key, Value val){
        root = put(root, key, val, 0);
    }
    private Node put(Node x, String key, Value val, int d){
        if (x == null)
            x = new Node();
        if (d == key.length()){
            x.val = val;
            return x;
        }
        char c = key.charAt(d);
        x.next[c] = put(x.next[c], key, val, d+1);
        return x;
    }
```

###### 删除

- 找到键所对应的结点并将值设为空（null）；
- 若值和链接均为空，则删去结点（返回一个空链接）。
- 若值或链接非空，不能删去结点（返回指向结点的链接）。
```
@Override
    public void delete(String key){
        root = delete(root, key, 0);
    }
    private Node delete(Node x, String key, int d){
        if (x == null)
            return null;
        if (d == key.length())
            x.val = null;
        else{
            char c = key.charAt(d);
            x.next[c] = delete(x.next[c], key, d + 1);
        }

        if (x.val != null)
            return x;
        for (char c = 0; c < R; c++){
            if (x.next[c] != null)
                return x;
        }
        return null;
    }
```

###### 大小

延时递归实现：
```
 @Override
    public int size(){
        return size(root);
    }
    private int size(Node x){
        if (x == null)
            return 0;
        int cnt = 0;
        if (x.val != null)
            cnt++;
        for (char c = 0; c < R; c++)
            cnt += size(x.next[c]);
        return cnt;
    }
```

###### 查找所有键

- keysWithPrefix()接受一个字符串参数并返回符号表中所有以该字符串作为前缀的键。

```
public Iterable<String> keys(){
        return keysWithPrefix("");
    }
    public Iterable<String> keysWithPrefix(String pre){
        Queue<String> q = new LinkedList<String>();
        collect(get(root, pre, 0), pre, q);
        return q;
    }
    private void collect(Node x, String pre, Queue<String> q){
        if (x == null)
            return ;
        if (x.val != null)
            q.add(pre);
        for (char c = 0; c < R; c++)
            collect(x.next[c], pre + c, q);
    }
```   

#### 图

<!--Note-->
##### 图的定义
- **图**按照有无方向分为**无向图**和**有向图**。无向图由**顶点**和**边**构成，有向图由顶点和**弧**构成。弧有**弧尾**和**弧头**之分。

- 图按照边或弧的多少分**稀疏图**和**稠密图**。如果任意两个顶点之间都存在边叫**完全图**，有向的叫**有向完全图**。若无重复的边或顶点到自身的边则叫**简单图**。

- 图中顶点之间有**邻接点、依附**的概念。无向图顶点的边数叫做**度**，有向图顶点分为**入度**和**出度**。

- 图上的边或弧上带**权**则称为**网**。

- 图中顶点间存在**路径**，两顶点存在路径则说明是**连通**的，如果路径最终回到起始点则称为**环**，当中不重复叫**简单路径**。若任意两顶点都是连通的，则图就是**连通图**，有向则称**强连通图**。图中有子图，若子图极大连通则就是**连通分量*，有向的则称为**强连通分量**。

- 无向图中连通且 **n** 个顶点 **n-1** 条边叫**生成树**。有向图中一顶点入度为 **0**，其余顶点入度为 **1**的叫**有向树**。一个有向图由若干棵有向树构成**生成森林**。

##### 图的存储结构
- 邻接矩阵：一个二维数组存储图中的边或弧的信息。例如，`arc[0][1]`表示v0到v1的边或弧。

- 邻接表：用一个单链表数组来存储。数组下标对应图的顶点，链表中存储该顶点的所有邻接点。

- 十字邻接表：对于有向图，在邻接表的基础上添加指向入边的指针，将邻接表和逆邻接表整合。

- 邻接多重表：对于无向图，表示同一条边在邻接表中需要用两个结点，而邻接多重表只要一个结点。

- 边集数组：由两个一维数组构成。一个存储顶点信息，另一个存储边的信息。

##### 图的遍历
- **深度优先遍历**：从图中某个顶点开始，沿未被访问的邻接点出发遍历图。经过一次深度优先遍历后，若图中尚有顶点未被访问，则另选图中一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

- **广度优先遍历**：从图中某顶点开始，将其存入队列中。从队列中出列一个顶点，将该顶点所有未被访问的邻接点入列，重复上述操作，直至图中所有顶点都被访问到为止。
<!--/Note-->

##### 最短路径

- 求某一顶点到其余所有顶点的最短路径问题用Dijkstra算法；求所有顶点到所有顶点的最短路径问题用Floyd算法，算法更简洁。

###### Dijkstra算法

- Dijkstra算法解决了从某一顶点到其余顶点的最短路径问题，其时间复杂度为 *O(n²)*。
- 若求任意顶点到其余所有顶点的最短路径时，即对每一顶点执行一次Dijkstra算法，其时间复杂度为 *O(n³)*。

```

typedef int Patharc[MAXVEX]; 
typedef int ShortPathTable[MAXVEX];

void ShortestPath_Dijkstra(MGraph G, int v0, Patharc *P, ShortPathTable *D)
{// P[v]表示v0到v最短路径的前驱顶点，D[v]表示v0到v的最短路径长度和 
	int v, w, k, min;
	int final[MAXVEX];

	for (v = 0; v < G.numVertexes; v++)
	{
		(*P)[v] = v0;
		(*D)[v] = G.arc[v0][v];
		final[v] = 0;
	}
	(*D)[v0] = 0;
	final[v0] = 1;

	for (v = 1; v < G.numVertexes; v++)
	{
		min = INFINITY;
		for (w = 0; w < G.numVertexes; w++)
		{
			if (!final[w] && (*D)[w] < min)
			{
				min = (*D)[w];
				k = w;
			}
		}
		final[k] = 1;
		for (w = 0; w < G.numVertexes; w++)
		{
			if (!final[w] && (min + G.arc[k][w] < (*D)[w]))
			{
				(*D)[w] = min + G.arc[k][w];
				(*P)[w] = k;
			}
		}
	}
}
```

###### Floyd算法

- Floyd算法解决了所有顶点到所有顶点的最短路径问题，其时间复杂度为 *O(n³)*。

```
typedef int Patharc[MAXVEX][MAXVEX];
typedef int ShortPathTable[MAXVEX][MAXVEX];

void ShortestPath_Floyd(MGraph G, Patharc *P, ShortPathTable *D)
{
	int v, w, k;
	for (v = 0; v < G.numVertexes; v++)
	{
		for (w = 0; w < G.numVertexes; w++)
		{
			(*D)[v][w] = G.arc[v][w];
			(*P)[v][w] = w;
		}
	}
	for (k = 0; k < G.numVertexes; k++)
	{
		for (v = 0; v < G.numVertexes; v++)
		{
			for (w = 0; w < G.numVertexes; w++)
			{
				if ((*D)[v][w] > (*D)[v][k] + (*D)[k][w])
				{
					(*D)[v][w] = (*D)[v][k] + (*D)[k][w];
					(*P)[v][w] = (*P)[v][k];
				}
			}
		}
	}
}
```

##### 最小生成树

- Kruskal算法主要针对边来展开，边上少时效率会非常高，所以对于稀疏图有很大的优势；Prim算法对于稠密图，即边数非常多的情况会更好一些。

###### Prim算法

- 对于n个顶点，Prim算法的时间复杂度为 *O(n²)*。

```
void MiniSpanTree_Prim(MGraph G)
{
	int min, i, j, k;
	int adjvex[MAXVEX]; // 存储生成树中与下标顶点最近的邻接点
	int lowcost[MAXVEX]; // 存储生成树到下标顶点的最小权重
	adjvex[0] = 0;
	lowcost[0] = 0;
	for (i = 1; i < G.numVertexes; i++)
	{
		adjvex[i] = 0;
		lowcost[i] = G.arc[0][i];
	}
	
	for (i = 1; i < G.numVertexes; i++)
	{
		min = INFINITY;
		k = 0;
		for (j = 1; j < G.numVertexes; j++)
		{
			if (lowcost[j] != 0 && lowcost[j] < min)
			{
				min = lowcost[j];
				k = j;
			}
		}
		printf("(%d, %d)", adjvex[k], k);
		lowcost[k] = 0;

		for (j = 1; j < G.numVertexes; j++)
		{
			if (lowcost[j] != 0 && G.arc[k][j] < lowcost[j])
			{
				adjvex[j] = k;
				lowcost[j] = G.arc[k][j];
			}
		}
	}
}
```

#######  

###### Kruskal算法

- 对于e条边，Find函数的时间复杂度为 *O(loge)*，故Kruskal算法的时间复杂度为*O(eloge)*。

```

/* Kruskal算法生成最小生成树 */
void MiniSpanTree_Kruskal(MGraph G)
{
	int i, n, m;
	Edge edges[MAXEDGE];
	int parent[MAXVEX]; 
	/* 此处省略将邻接矩阵G转化为边集数组并按权从小到大排序的代码 */
	for (i = 0; i < G.numVertexes; i++)
		parent[i] = 0;

	for (i = 0; i < G.numEdges; i++)
	{
		n = Find(parent, edges[i].begin);
		m = Find(parent, edges[i].end);
		if (n != m)
		{
			printf("(%d, %d) %d ", edges[i].begin, edges[i].end, edges[i].weight);
			parent[n] = m;
		}
	}
}

int Find(int *parent, int f)
{
	while (parent[f] > 0)
		f = parent[f];
	return f;
}
```

#######  

##### 拓扑排序

- 对于n个顶点e条弧的AOV网，扫描顶点表将入度为0的顶点入栈的时间复杂度为 *O(n)*, 每个顶点入栈一次，出栈一次，入度减1的操作共执行e次，所以整个算法的时间复杂度为 *O(n+e)*。

```
/******** 邻接表 *********/
struct EdgeNode
{
	int adjvex;
	int weight;
	EdgeNode *next;
};

typedef struct VertexNode
{
	int in;
	int data;
	EdgeNode *firstedge;
}AdjList[MAXVEX];

typedef struct
{
	AdjList adjList;
	int numVertexes, numEdges;
}graphAdjList, *GraphAdjList;
```

```
/* 拓扑排序，若GL无回路返回0，若有回路返回-1 */
int TopologicalSort(GraphAdjList GL)
{
	EdgeNode *e;
	int i, k, gettop;
	int top = -1;
	int count = 0;
	int *stack;
	stack = (int *)malloc(GL->numVertexes * sizeof(int));
	for (i = 0; i < GL->numVertexes; i++)
		if (GL->adjList[i].in == 0)
			stack[++top] = i;
	while (top >= 0)
	{
		gettop = stack[top--];
		printf("%d -> ", GL->adjList[gettop].data);
		count++;
		for (e = GL->adjList[gettop].firstedge; e; e = e->next)
		{
			k = e->adjvex;
			if (--GL->adjList[k].in == 0)
				stack[++top] = k;
		}
	}
	if (count < GL->numVertexes)
		return -1;
	else
		return 0;
}
```

##### 并查集

用于解决动态连通性问题，能动态连接两个点，并且判断两个点是否连通。

方法|描述
-|-
UF(int N)|以整数标识（0到N-1）初始化N个节点
void union(int p, int q)|连接p和q节点
int find(int p)|查找p（0到N-1）所在的分量的标识符
boolean connected(int p, int q)|判断p和q是否在同一个连通分量中
int count()|连通分量的数量

```

public abstract class UF {
    protected int[] id;
    protected int count;
    public UF(int N){
        count = N;
        id = new int[N];
        for (int i = 0; i < N; i++)
            id[i] = i;
    }
    public abstract void union(int p, int q);
    public abstract int find(int p);
    public boolean connected(int p, int q){
        return find(p) == find(q);
    }
    public int count(){
        return count;
    }
}
```

算法|union|find   
-|-|-
quick-find算法|N|1
quick-union算法|树高|树高
加权quick-union算法|logN|logN
路径压缩的加权quick-union算法|非常接近 1	|非常接近 1

###### quick-find算法

- 可以快速进行 find 操作，也就是可以快速判断两个节点是否连通。

- 需要保证同一连通分量的所有节点的 id 值相等，就可以通过判断两个节点的 id 值是否相等从而判断其连通性。

- 但是 union 操作代价却很高，需要将其中一个连通分量中的所有节点 id 值都修改为另一个节点的 id 值。

```

public class QuickFindUF extends UF {
    public QuickFindUF(int N){
        super(N);
    }

    @Override
    public int find(int p){
        return id[p];
    }

    @Override
    public void union(int p, int q){
        int pID = find(p);
        int qID = find(q);

        if (pID == qID) return;

        for (int i = 0; i < id.length; i++){
            if (id[i] == pID)
                id[i] = qID;
        }
        count--;
    }
}
```

###### quick-union算法

- 可以快速进行 union 操作，只需要修改一个节点的 id 值即可。

- 但是 find 操作开销很大，因为同一个连通分量的节点 id 值不同，id 值只是用来指向另一个节点。因此需要一直向上查找操作，直到找到最上层的节点。

- find 操作和树高成正比，最坏的情况下树的高度为节点的数目。

```
public class QuickFindUF extends UF {
    public QuickFindUF(int N){
        super(N);
    }

    @Override
    public int find(int p){
        return id[p];
    }

    @Override
    public void union(int p, int q){
        int pID = find(p);
        int qID = find(q);

        if (pID == qID) return;

        for (int i = 0; i < id.length; i++){
            if (id[i] == pID)
                id[i] = qID;
        }
        count--;
    }
}
```

###### 加权quick-union算法

- 为了解决 quick-union 的树通常会很高的问题，加权 quick-union 在 union 操作时会让较小的树连接较大的树上面。

- 理论研究证明，加权 quick-union 算法构造的树深度最多不超过 logN。

```
public class WeightedQuickUnionUF extends UF {
    private int[] sz;
    public WeightedQuickUnionUF(int N){
        super(N);
        sz = new int[N];
        for(int i = 0; i < N; i++)
            sz[i] = 1;
    }

    @Override
    public int find(int p){
        while (p != id[p])
            p = id[p];
        return p;
    }

    @Override
    public void union(int p, int q){
        int i = find(p);
        int j = find(q);
        if (i == j) return;
        if (sz[i] < sz[j]){
            id[i] = j;
            sz[j] += sz[i];
        }
        else{
            id[j] = i;
            sz[i] += sz[j];
        }
        count--;
    }
}

```

###### 路径压缩的加权quick-union算法

在检查节点的同时将它们直接链接到根节点，只需要在 find 中添加一个循环即可。

##### 网络流

#### 其它

##### 汉诺塔

##### 哈夫曼编码

### 海量数据处理

#### TOP-K

#### 海量数据判重

#### 海量数据排序

#### MapReduce

### 数学与逻辑

#### 概率题

##### 抢红包

##### 洗牌

##### 蓄水池抽样

##### Rand7

#### 智力题

### LeetCode

#### 双指针

<!--Note-->
####### 需要对元素做对比
- 主要用于需要**遍历**数组，字符串，链表等。
- 同个集合或不同集合的两个元素，需要进行**对比、交换、运算**等操作。
<!--/Note-->

#### 排序

##### Kth and TopK

- **sort()排序**：时间复杂度 O(NlogN)，空间复杂度 O(1)
- **堆**：时间复杂度 O(NlogK)，空间复杂度 O(K)。适用于海量数据。
- **快速选择**：时间复杂度 O(N)，空间复杂度 O(1)。会改变原数组。

##### 出现频率排序

###### 桶排序

```
public List<Integer> frequencyBucket(int[] nums, int k) {
    Map<Integer, Integer> frequencyForNum = new HashMap<>();
    for (int num : nums) {
        frequencyForNum.put(num, frequencyForNum.getOrDefault(num, 0) + 1);
    }
    List<Integer>[] buckets = new ArrayList[nums.length + 1];
    for (int key : frequencyForNum.keySet()) {
        int frequency = frequencyForNum.get(key);
        if (buckets[frequency] == null) {
            buckets[frequency] = new ArrayList<>();
        }
        buckets[frequency].add(key);
    }
}
```

##### 荷兰国旗

###### 三向切分

```
protected void ThreeWayPartition(int[] nums, int v) {
   int lt = 0, i = 0, gt = nums.length;
   while (i <= gt) {
        if (nums[i] < v) {
            swap(nums, lt++, i++);
        } else if (nums[i] > v) {
            swap(nums, i, gt--);
        } else {
            i++;
        }
    }
}
```

#### 贪心算法

<!--Note-->
####### 寻找最优解
必定一次遍历数组或字符串的过程，在遍历过程中保证遍历过的局部最优，最后达到全局最优。

<!--/Note-->

##### 区间数组

相对数组内的区间进行排序，在贪心遍历。

#### 二分查找

<!--Note-->
####### 有序集合中寻找某值或边界

<!--/Note-->

##### 查找某值

```
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (nums[m] == key) {
            return m;
        } else if (nums[m] > key) {
            h = m - 1;
        } else {
            l = m + 1;
        }
    }
    return -1;
}
```

##### 查找边界

例如，1 2 2 2 3, key = 2, 返回最左边的2；1 2 4 5 6, key = 3, 返回4。
```
public int binarySearch(int[] nums, int key) {
    int l = 0, h = nums.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= key) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```
- h 的赋值表达式为 h = m
- 循环条件为 l < h
- 最后返回 l 而不是 -1


#### 二分治

<!--Note-->
####### 需要罗列多种情况
- 把复杂问题分成两个子问题，在假设子问题已解决的情况下求解，子问题再递归求解。
- 如快速排序、归并排序。

<!--/Note-->

#### 搜索

##### bfs

<!--Note-->
######## 用于寻找根节点到叶节点的最短路径。
- 队列Queue
- 
- 标记数组visited
```
private void bfs(Graph G, int s) {
	Queue<Integer> queue = new LinkedList<>();
    visited[s] = true;
    queue.add(s);
    while (!queue.isEmpty()) {
    	int v = queue.remove();
        for (int w : G.adj(v)) {
        	if (!visited[w]) {
            	edgeTo[w] = v;
                visited[w] = true;
                queue.add(w);
            }
        }
    }
}
```
<!--/Note-->

##### dfs

<!--Note-->
######## 用于寻找连通区域。
```
private void dfs(Grapth G, int v){
	maked[v] = true;
    for (int w : G.adj(v)) {
    	if (!marked[w]) {
        	edgeTo[w] = v;
            dfs(G, w);
        }
    }
}
```
<!--/Note-->

##### backtracking

<!--Note-->
######## 用于寻找排列组合等多种情况的集合。
```
private void backtracking(List<List<Integer>> lists, List<Integer> list, boolean[] visited, final int[] a) {
    if (list.size() == a.length) {
        lists.add(new ArrayList<>(list)); // 重新构造一个 List
        return;
    }
    for (int i = 0; i < visited.length; i++) {
        if (visited[i]) {
            continue;
        }
        visited[i] = true;
        list.add(a[i]);
        backtracking(lists, list, visited, a);
        list.remove(list.size() - 1);
        visited[i] = false;
    }
}
```
<!--/Note-->

#### 动态规划

<!--Note-->
####### 给定数组、双字符串或n，返回int或boolean
穷举找规律，列出转移方程。

状态转移方程常用格式：
```
dp[i] = dp[i - 1]; // 表达式
dp[i] = Math.max(dp[i], dp[i - 1]); // 比较大小
dp[i] = dp[i] || dp[i - 1]; // 返回boolean
```
<!--/Note-->

##### 斐波那契数列

##### 0-1背包

```
// W 为背包总体积
// N 为物品数量
// weights 数组存储 N 个物品的重量
// values 数组存储 N 个物品的价值
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = 1; j <= W; j++) {
            if (j >= w) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - w] + v);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[N][W];
}
```
空间优化后：
```
public int knapsack(int W, int N, int[] weights, int[] values) {
    int[] dp = new int[W + 1];
    for (int i = 1; i <= N; i++) {
        int w = weights[i - 1], v = values[i - 1];
        for (int j = W; j >= w; j--) {
            dp[j] = Math.max(dp[j], dp[j - w] + v);
        }
    }
    return dp[W];
}
```

###### 数组元素和为目标值

将题目转化为求数组中元素和为target的组合数，即01背包问题中，背包刚好装满的组合数。

```
public int zeroOnePack(int[] nums, int target) {
	int n = nums.length;
	int[][] dp = new int[n + 1][target + 1];
	for (int i = 1; i < n + 1; i++) {
		for (int j = 1; j < target + 1; j++) {
			if (nums[i - 1] == j) {
            	dp[i][j] = dp[i - 1][j] + 1;
            } else if (nums[i - 1] < j) {
            	dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
            } else {
            	dp[i][j] = dp[i - 1][j];
            }
        }
	}
	return dp[n][target];
}
```

优化后：
```
public int zeroOnePack(int[] nums, int target) {
	int[] dp = new int[target + 1];
	dp[0] = 1;
	for (int num : nums) {
		for (int i = target; i >= num; i--) {
			dp[i] += dp[i - num];      
        }
	}
	return dp[target];
}
```

###### 多维背包

###### 完全背包

####### 逆序遍历改为正序

##### 两个字符串

```
public int twoStr(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    int[][] dp = new int[m + 1][n + 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                dp[i][j] = f1(dp[i - 1][j - 1]);
            } else {
                dp[i][j] = f2(dp[i][j - 1], dp[i - 1][j]);
            }
        }
    }
    return dp[m][n];
}
```

##### 返回boolean

```
dp[0] = true; // 赋初始值
dp[i] = dp[i - j] || dp[i - k]; // 状态转移
```

#### 数学

## 操作系统

<!--Note-->
### 资料

- 《现代操作系统》
- 《深入理解计算机系统》
- 《UNIX 环境高级编程》
- 《Unix/Linux 编程实践教程》
- 《鸟哥的 Linux 私房菜》
- 《The Linux Command Line》
<!--/Note-->

### 基础

#### 进程管理

##### 进程与线程

###### 进程

进程是资源分配的基本单位。

进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

###### 线程

**线程**：进程由资源平台和线程组成。线程是进程在资源平台上的一条执行流程。

**线程的优点**：
- 一个进程中可以同时存在多个线程；
- 各个线程之间可以并发地执行；
- 各个线程之间可以共享地址空间和文件等资源。

**线程的缺点**：
- 一个线程崩溃，会导致其所属进程的所有线程崩溃。

###### 线程与进程的比较

- 进程是资源分配单位，线程是CPU调度单位；
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
- 线程同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系；
- 线程能减少并发执行的时间和空间开销：
	- 线程的创建时间比进程短；
    - 线程的终止时间比进程短；
    - 同一进程内的线程切换时间比进程短；
    - 由于同一进程的个线程间共享内存和文件资源，可直接进行不通过内核的通信。

##### 进程状态

###### 就绪状态（ready）

####### 缺少CPU时间，不占用资源

###### 运行状态（running）

####### 同时拥有CPU时间和资源

###### 阻塞状态（waiting）

####### 缺少资源，不占用CPU时间

##### 进程调度算法

###### 批处理系统

批处理系统用来处理周期性的作业，没有太多的用户操作。

批处理系统调度算法的目标：
- 吞吐量——每小时最大作业数
- 周转时间——从提交到终止间的最小时间
- CPU利用率——保持CPU始终忙碌



####### 先来先服务first-come first-served(FCFS)

最简单的非抢占式调度算法，进程按照它们请求CPU的顺序使用CPU。如果进程在执行中被阻塞，就绪队列中的第一个会得到CPU。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

####### 最短作业优先shortest job first(SJF)

适用于运行时间可预知的非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

########  

####### 最短剩余时间优先shortest remaining time next(SRTN)

最短作业优先的抢占式版本。调度程序总是选择剩余运行时间最短的那个进程运行。

###### 交互式系统

交互式系统有大量的用户交互操作，而且抢占是必须的。

交互式系统调度算法的目标：
- 响应时间——快速响应请求
- 均衡性——满足用户的期望

####### 轮转调度

将所有就绪进程按 FCFS 的原则排成一个队列，每个进程被分配一个时间片。当队首进程时间片用完时，将它移至就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转调度的效率和时间片的大小有很大关系：
- 时间片设得太短会导致过多的进程切换，降低CPU效率；
- 而设得太长又可能引起对短的交互请求的响应时间变长。
- 将时间片设为20~50ms通常是一个比较合理的折中。

########  

####### 优先级调度

每个进程被赋予一个优先级，允许优先级最高的可执行程序先执行。

- 为了防止高优先级进程无休止地运行下去，调度程序可能在每个时钟中断降低当前进程的优先级。
- 优先级可以是静态赋予或动态赋予。
- 可以将一组进程按优先级分为若干类，并且在各类之间采用优先级调度，而在各类进程的内部采用轮转调度。

########  

####### 多级队列

属于最高优先级类的进程运行1个时间片，属于次高优先级类的进程运行2个时间片，再次一级运行4个时间片，以此类推。当一个进程用完分配的时间片后，它被移动下一类。那么一个进程被分配的时间片依次是1、2、4、8、16...

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

########  

###### 实时系统中的调度

实时系统要求一个请求在一个确定时间内得到响应。

实时系统调度算法的目标：
- 满足截止时间——避免丢失数据
- 可预测性——在多媒体系统中避免品质降低

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

##### 线程实现方式

###### 用户线程

<!--Note-->
######### 在用户空间实现的线程机制，它不依赖于操作系统的内核，由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度。
- 由于用户线程的维护由相应进程来完成（通过线程库函数），**不需要操作系统内核了解用户线程的存在**，可用于不支持线程技术的多进程操作系统。
- **每个进程都有自己私有的线程控制块（TCB）列表**，用来跟踪记录它各个线程的状态信息（PC、栈指针、寄存器），TCB由线程库函数来维护。
- **用户线程的切换也是由线程库函数来完成的**，无需用户态/内核态切换，所以**速度特别快**。
- **允许每个进程都有自定义的线程调度算法**。

######### 用户线程的缺点：
- 如果一个线程发起系统调用而阻塞，则整个进程在等待。
- 运行中的线程只有主动地交出CPU的使用权后才运行进程中的其他线程。
- 由于时间片分配给进程，故与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢。
<!--/Note-->

#######  

###### 内核线程

<!--Note-->
######### 是指在操作系统中的内核当中实现的一种线程机制，有操作系统的内核来完成线程的创建、终止和管理。
- 在支持内核线程的操作系统中，**由内核来维护进程和线程的上下文信息（PCB和TCB）**；
- **线程的创建、终止和切换都是通过系统调用/内核函数的方式来进行**，由内核来完成，因此系统**开销较大**；
- 在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行；
- **时间片分配给线程**，多线程的进程获得更多CPU时间。
<!--/Note-->

#######  

###### 轻量级进程

<!--Note-->
######### 它是内核支持的用户线程。一个进程可有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持。
<!--/Note-->

##### 协程

##### 进程同步

###### 竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精准时序，称为竞争条件（race condition）。


###### 临界区

对共享内存进行访问的程序片段称为临界区（cirtical section）。

两个进程不同时处于临界区，就能够避免竞争条件。

共享数据并发进程正确高效地进行协作的条件：
	1）任何两个进程不能同时处于其临界区。
    2）不应对CPU速度和数量做任何假设。
    3）临界区外运行的进程不得阻塞其他进程。
    4）不得使进程无限期等待进入临界区。

###### 实现方法

####### 互斥方法

######## 屏蔽中断

使每个进程进入临界区后屏蔽所有中断，在要离开之前再打开中断。

屏蔽中断适用于操作系统本身，而不适用于用户进程。

######## 软件方法

######### 严格轮换法

连续测试一个变量直到某个值出现为止，称为**忙等待**。该方式浪费CPU时间，应该避免。

用于忙等待的锁，称为**自旋锁**。

##########  

turn值为0，允许进程0进入临界区，进程0离开临界区时，turn值设为1，允许进程1进入临界区，进程1离开临界区时，turn值设为0.

######### Peterson算法

```
while(TRUE){
	flag[i] = TRUE;
    turn = j;
    while (flag[j] && turn == j);
    	
        CRITICAL SECTION
        
    flag[i] = FALSE;
    
    	REMAINDER SECTION
        
}
```

######## 原子操作

原子操作是指一组相关的操作要么都不间断地执行，要么都不执行。

######### TLS(test and set lock)

```
boolean TestAndSet(boolean *target){
	boolean rv = *target;
    *target = TRUE;
    return rv;
}

class Lock{
	int value = 0;
}

Lock::Acquire(){
	while(TestAndSet(value);
}

Lock::Release(){
	value = 0;
}
```

######### XCHG(exchange)

```
void Exchange(boolean *a, boolean *b)
{
	boolean temp = *a;
    *a = *b;
    *b = temp;
}

class Lock{
	int lock = 0;
    int key = 1;
}

Lock::Acquire(){
	key = 1;
	while(key == 1)
    	Exchange(lock, key);
}

Lock::Release(){
	lock = 0;
}
```



####### 信号量

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。

- down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作均是不可分割的原子操作，在执行这些操作时屏蔽中断。

######## 使用信号量解决生产者-消费者问题

生产值-消费者（有界缓冲区）问题：两个进程共享一个固定大小的缓冲区。生产者将信息放入缓冲区，消费者从缓冲区取出信息。缓冲区属于临界资源。

```
private LinkedList<Object> list = new LinkedList<Object>();
private static final int N = 10;
// 互斥量
private final Semaphore mutex = new Semaphore(1);
// 空位
private final Semaphore empty = new Semaphore(N);
// 满位
private final Semaphore full = new Semaphore(0);

public void producer() {
    while(true) {
    	empty.acquire();
        mutex.acquire();
        list.add(new Object());
        mutex.release();
        full.release();
        
        Thread.sleep(1000);
    }
}

public void consumer() {
    while(true) {
    	full.acquire();
        mutex.acquire();
        list.remove();
        mutex.release();
        empty.release();
        
        Thread.sleep(1000);
    }
}
```

####### 管程（monitor）

管程（monitor）是由过程、变量及数据结构等组成的一个集合。

在任一时刻管程中只能有一个活跃进程。

进入管程时的互斥由编译器负责，出错的可能性更小。

```
monitor example
	integer i;
    condition c;
    
    procedure insert();
    ...
    end;
    
    procedure consumer();
    ...
    end;
end monitor;
```




######## 条件变量

管程提供互斥，但还需要引入**条件变量**使得进程无法继续运行时被阻塞。相关的两个操作：wait和signal。对条件变量执行wait操作会导致进程调用阻塞，可令其他进程调用管程。signal操作用于唤醒被阻塞的进程。

```
// 管程
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;

    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;

    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;

// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;

// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

##### 经典进程同步问题

###### 哲学家进餐问题

错误解法1————无法拿起叉子时阻塞：如果5位哲学家同时拿起左叉，则都拿不到右叉，发生死锁。
错误解法2————无法拿起叉子时思考一段时间后再尝试：如果同时拿起左叉，则都拿不到右叉，都等待相同时间后再尝试，如此重复下去，产生饥饿。

```
#define N 5

void philosopher(int i)
{
	while (TRUE){
    	think();
        take_fork(i);
        take_fork((i+1) % N);
        eat();
        put_fork(i);
        put_fork((i+1) % N);
    }
}
```

- 使用一个二元信号量对调用think之后的语句进行保护，可防止死锁和产生饥饿。
- 使用一个state数组跟踪每个哲学家是进餐、思考还是饥饿状态，可获得最大的并行度。

```

#define N 5
#define LEFT (i+N-1) % N // 左邻居
#define RIGHT (i+1) % N // 右邻居
#define THINKING 0
#define HUNGRY 1
#define EATING 2
typedef int semaphore;
int state[N];
semaphore mutex = 1;
semaphore s[N];

void philosopher(int i)
{
	while(TRUE){
    	think();
        take_forks(i);
        eat();
        put_forks(i);
    }
}

void take_forks(int i)
{
	down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}

void put_forks(i)
{
	down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}

void test(i)
{
	if(state[i] == HUNGRY && state[LEFT] != EATING 
    && state{RIGHT] != EATING){
    	state[i] = EATING;
        up(&s[i]);
    }
}
```

###### 读者-写者问题

允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。

```
typedef int semaphore;
semaphore mutex = 1; // 控制对rc的访问
semaphore db = 1; // 控制对数据库的访问
int rc = 0; // 正在读或者即将读的进程数目

void reader(void)
{
	while (TRUE) {
    	down(&mutex);
        rc = rc + 1;
        if (rc == 1) down(&db); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&mutex);
        read_data_base();
        down(&mutex);
        rc = rc - 1;
        if (rc == 0) up(&db);
        up(&mutex);
        use_data_read();
    }
}

void writer(void)
{
	while (TRUE) {
    	think_up_data();
        down(&db);
        write_data_base();
        up(&db);
    }
}
```

##### 进程间通信IPC

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 通讯方式总结

1.管道：速度慢，容量有限，只有父子进程能通讯    

2.FIFO：任何进程间都能通讯，但速度慢    

3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    

4.信号量：不能传递复杂消息，只能用来同步    

5.共享内存区：能够很容易控制容量，速度快，但要保持同步
————————————————
https://blog.csdn.net/wh_sjc/article/details/70283843



###### 管道

管道，通常指无名管道。


### 1.特点：
- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用；
- 是一种特殊文件，只存在于内存中。


### 2.原型
```
#include <unistd.h>
int pipe(int fd[2]);    // 返回值：若成功返回0，失败返回-1
```
通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

####### 图

########  

####### 半双工

####### 存于内存

####### 父子进程

###### FIFO

FIFO，也称为命名管道，它是一种文件类型。

### 1.特点
- 可用于无关进程交换数据，与无名管道不同。

- 以一种特殊设备文件存在于文件系统中。

### 2.原型

```
#include <sys/stat.h>
// 返回值：成功返回0，出错返回-1
int mkfifo(const char *pathname, mode_t mode);
```

FIFO的通信方式类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性。在数据读出时，FIFO管道中同时清除数据，并且“先进先出”。常用于客户-服务器应用程序中。


####### 图

########  

####### 无关进程

####### 存于文件系统

###### 消息队列

消息队列，是消息的链接表，存放在内核中。

### 特点
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法

- 消息队列独立于读写进程。进程终止时，消息队列及其内容不会被删除。

- 消息队列可实现消息随机查询，可按消息类型读取，不像FIFO以先进先出次序读取。


####### 存于内核

####### 独立于读写进程

####### 异步

####### 消息随机查询

###### 信号量

信号量（semaphore）是一个计数器，用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

### 特点
- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。

- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。

- 每次对信号量的 PV 操作不仅限于加 1 或减 1，可加减任意正整数。

- 支持信号量组。

####### 用于互斥同步

###### 共享存储

共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。
### 特点
- 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。

- 因为多个进程可以同时操作，所以需要进行同步。

- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

####### 最快IPC

####### 需要信号量协作同步

###### socket套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

#### 死锁

- 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。

##### 必要条件

发生死锁的4个必要条件：
- 1）**互斥条件**。每个资源要么已经分配给一个进程，要么就是可用的。
- 2）**占有和等待条件**。已经得到某个资源的进程可以在请求新的资源。
- 3）**不可抢占条件**。已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 4）**环路等待条件**。死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，该环路中的每个进程都在等待着下一个进程所占有的资源。

######  

##### 处理死锁的方法

四种处理的策略：
- 1）忽略该问题。也许如果你忽略它，它也会忽略你。
- 2）检测死锁并恢复。让死锁发生，检测它们是否发生，一旦发生死锁，采取行动解决问题。
- 3）仔细对资源进行分配，动态地避免死锁。
- 4）通过破坏引起死锁的四个必要条件之一，防止死锁的产生。

###### 鸵鸟算法

鸵鸟算法：把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。

###### 死锁检测和死锁恢复

系统不试图阻止死锁的产生，而是允许死锁发生，当检测到死锁发生后，采取措施进行恢复。





####### 每种类型一个资源的死锁检测

<!--Note-->
########## 每种类型一个资源的死锁检测
可以对系统构造一张资源分配图，如果图中包含环，则存在死锁。

通过算法来检测有向图中是否存在环，从而检测死锁。

算法依次从每个节点出发进行深度优先搜索，如果碰到已经遇到的节点，那么就算找到了一个环。
<!--/Note-->

####### 每种类型多个资源的死锁检测

<!--Note-->
########## 每种类型多个资源的死锁检测
E 现有资源向量：每种已存在的资源总数。
A 可用资源向量：当前可供使用的资源数。
C 当前分配矩阵：每个进程当前所持有的每一种类型资源的资源数。
R 请求矩阵：每个进程所需要的每种类型资源的数量。

每个进程起初都不被标记，开始后会对能够被执行的算法进行标记。当算法结束时，任何没有被标记的进程都是死锁进程。

死锁检测算法如下：
- 1）寻找一个没有标记的进程 Pᵢ，R 矩阵的第 i 行向量小于等于 A。
- 2）如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转到第 1）步。
- 3）如果没有这样的进程，算法终止。

如图，进程 Pᵢ 和 P₂ 所请求的资源都得不到满足，只有进程 P₃ 可以，让 P₃ 执行，之后释放 P₃ 拥有的资源，此时 A = (2 2 2 0)。P₂ 可以执行，执行后释放 P₂ 拥有的资源，A = (4 2 2 1) 。Pᵢ 也可以执行。所有进程都可以顺利执行，没有死锁。
<!--/Note-->

####### 从死锁中恢复

<!--Note-->
########## 1.利用抢占恢复
临时将某个资源从一个进程强行取走给另一个进程使用，接着又送回。

########## 2.利用回滚恢复
周期性对进程进行检查点检查（即进程状态写入一个文件），一旦检测到死锁，恢复到较早的一个检查点。

########## 3.通过杀死进程恢复
最直接也是最简单的解决死锁的方法是杀死一个或若干个进程。
<!--/Note-->

###### 死锁避免

系统必须能判断分配资源是否安全，并且只能在保证安全的条件下分配资源。


####### 资源轨迹图 

阴影部分为 AB 两进程同时拥有打印机或绘图仪，则由互斥规则表示该区域无法进入。虚线表示进程的执行状态，运动方向只能是向上或向右。因此，如果系统一旦进入有I1、I2和I5、I6组成的矩形区域，则会进入死胡同，从而产生死锁。

####### 安全状态和不安全状态

如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每个进程进行完毕，则称该状态是安全的。

如图，依照B->C->A的次序运行进程能避免死锁，故状态是安全的。

不安全状态并不是死锁。从安全状态出发，系统能够保证所有进程都能完成，从不安全状态出发，就无法保证。

####### 单个银行家算法

一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，判断对请求的满足是否会导致进入不安全状态。如果是，就拒绝请求；否则，就给予分配。

####### 多个银行家算法

左边的矩阵显示了5个进程分别已分配的个各种资源数;右边的矩阵显示了使各进程完成运行所需的各资源数;最右边三个向量分别表示现有资源E、已分配资源P和可用资源A。

检查状态是否安全的算法如下：
- 1）查找右边矩阵是否有一行小于或等于A。若不存在，则系统将会死锁。
- 2）若找到这样一行，将该进程标记为终止，并将其资源加到向量A上。
- 3）重复以上两步，直到所有进程都标记为终止，其初始状态是安全的；否则，就会发生死锁。



###### 死锁预防

如果能保证四个必要条件中至少有一个不成立，那么死锁将不会产生。

####### 破坏互斥条件

如果资源不被一个进程所独占，那么死锁肯定不会发生。

例如假脱机打印机（spooling printer）技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程，由于守护进程不会请求别的资源，所以不会因打印机而产生死锁。

####### 破坏占有并等待条件

只要禁止已持有资源的进程再等待其他资源便可消除死锁。

一种实现方法是规定所有进程在执行前请求所需的全部资源。

另一种方案是，要求当一个进程请求资源时，先暂时释放其当前占用的所有资源，然后再尝试一次获得所需的全部资源。

####### 破坏不可抢占条件

只要当一个进程申请一个资源，然而却申请不到的时候，必须释放已经申请到的所有资源。

####### 破坏环路等待条件

消除环路的几种方法：
- 保证每个进程在任何时刻只能占用一个资源，如果请求另一个资源，它必须先释放第一个资源。
- 进程所有请求必须按照资源编号的顺序提出。
- 要求不允许进程请求比当前所占有资源编号低的资源。

#### 内存管理

内存模型：
- 内核内存：提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。
- 用户内存：各个进程使用的主要空间。

##### 虚拟内存

**虚拟内存的目的**：是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

**虚拟内存的基本思想是**：每个程序拥有自己的地址空间，这个空间被分割成多个块，每个块称作一页或页面（page）。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行 程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。

###### 分页系统地址映射

由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。

在使用虚拟内存的情况下，虚拟地址被送到内存管理单元（Memory Management Unit, MMU）,MMU把虚拟地址映射为物理内存地址。

虚拟地址空间按照固定大小划分成被称为页面（page）的若干单元。在物理内存中对应的单元称为页框（page frame）。

若程序访问一个未映射的页面，会使CPU陷入到操作系统，这个陷阱称为缺页中断或缺页错误。

#######  

#######  

输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移可以为一页内的全部4096个字节编址。

可用页号作为页表的索引，以得出对应该虚拟页面的页框号。

##### 页面置换算法

PS:特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。

当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，以便为即将调入的页面腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

## 页面置换算法小结
算 法 |注 释
------|------
最优算法 | 不可实现，但可用作基准
NRU（最近未使用）算法 | LRU的很粗糙的近似
FIFO（先进先出）算法 | 可能抛弃重要页面
第二次机会算法 | 比FIFO有较大的改善
时钟算法 | 现实的
LRU (最近最少使用）算法 | 很优秀，但很难实现
NFU (最不经常使用）箕法 | LRU的相对粗略的近似
老化算法 | 非常近似LRU的有效算法
工作集算法 | 实现起来开销很大
工作集时钟算法 | 好的有效算法

###### 最优（OPT, Optimal replacement algorithm）

标记每个页面被访问前所要执行的指令数，最优页面置换算法规定应该置换标记最大的页面。

该算法无法实现，是一种理论上的算法，因为操作系统无法知道各个页面下一次将在什么时候被访问。

可以通过仿真程序运行时收集的信息实现最优页面置换算法，以用来与其他可实现算法的性能进行比较。

###### 最近未使用（NUR, Not Recently Used）

每个页面都有两个状态位：R 与 M，当页面被访问时设置 R 位，当页面被修改时设置 M 位。其中 R 位会定时被清零。可以将页面分成以下四类：

- 第0类：没有被访问，没有被修改。
- 第1类：没有被访问，已被修改。
- 第2类：已被访问，没有被修改。
- 第3类：已被访问，已被修改。

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的页面（R=0，M=1），而不是被频繁使用的“干净”页面（R=1，M=0）。

NRU 的主要优点是易于理解和能够有效地被实现，虽然性能不是最好的，但是够用。

###### 先进先出（FIFO, First-In First-Out）

由操作系统维护一个当前在内存中的所有页面的链表，最新进入的页面在尾部，最早进入的放在表头，每当发生缺页中断，就替换掉表头的页面并且把新调入的页面加入到链表末尾。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

###### 第二次机会（second chance）

针对FIFO算法可能将经常使用的页面置换出去，因此检查最老页面的R位。若R=0，立刻置换掉；若R=1，将R位清0并将该页面放到链表尾部。

#######  

###### 时钟（clock）

第二次算法经常在链表中移动页面，降低了效率。时钟算法把所有页面都保存在一个类似钟面的环形链表中，一个表针指向最老页面。

#######  

###### 最近最少使用（LRU, Least Recently Used）

在缺页中断发生时，置换未使用时间最长的页面，称为LRU。

LRU是可实现的，需要在内存中维护一个所有页面的链表，最近最多使用的放表头，最近最少使用的放表尾，每次访问内存时都需更新链表，代价较大。

很少有计算机能使用硬件实现LRU算法，因此需要能用软件实现的方法。NFU（Not Frequently Used，最不常用）算法将每个页面与一个软件计数器相关联，每次时钟中断时，扫描每个页面的R位并加到其计数器上，从而跟踪各个页面被访问的频率。

NFU存在的问题是很久之前的一次使用，与最近的使用权重相等。老化（aging）算法对其进行了改进：在R位加进之前将计数器右移一位，然后加到计数器的最左端的位。老化算法的计数器只能有限位数，因此限制了对以往页面的记录。

#######  

###### 工作集算法（WSClock）

简单来说，工作集就是在最近k次内存访问所使用过的页面的集合。原始的工作集算法同样代价很大，对它进行简化：在过去Nms的内存访问中所用到的页面的集合。

所以，在实现的时候，可以给每个页面一个计时器。需要置换页面时，同实际时间进行对比，R为1，更新到现在时间；R为0，在规定阈值之外的页面可以被置换。

同样，这个算法也可以用时钟的思想进行改进。

##### 分页与分段

###### 分段

分页存储管理：虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

一维的地址空间中，一个编译器在编译过程中会建立许多表，包括源程序正文、符号表、常量表、语法分析数、调用堆栈。前4个表随着编译的进行会不断地增长，使得地址空间中的块可能被装满，导致覆盖问题的出现。分段存储管理的方法可解决以上问题。

分段存储管理：每个段是一个独立的地址空间，段的长度可以是0到允许的任意值，可动态改变。不同的段长度可以不同。

- 若每个过程都位于独立的段中，那么把单独编译好的过程连接起来的操作会极大简化。
- 分段有助于几个进程之间共享过程和数据。将共享库放在一个独立的段中由各个进程共享。
- 每个段都是为程序员所知的逻辑实体，故不同的段可以有不同种类的保护。

#######  

#######  

###### 段页式

段页式存储管理：程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

###### 分页与分段的比较

考查点|分页|分段
-----|----|----
需要程序员了解正在使用这种技术吗？|否|是
存在多少线性地址空间？|1|许多
整个地址空间可以超出物理存储器的大小吗？|是|是
过程和数据可以被区分并分别被保护吗？|否|是
其大小浮动的表可以很容易提供吗？|否|是
用间过程的共享方便吗？|否|是
为什么发明这种技术？|为了得到大的线性地址空间而不必购买更大的物理存储器|为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护

#### 设备管理

##### 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。
- 柱面（Cylinder）：各个盘面上半径相同的磁道组成了一个圆柱面，称为磁盘的柱面 。柱面的个数与盘面上的磁道数相等。 

##### 磁盘调度算法

读写磁盘块所需时间的决定因素：

- 1）寻道时间（将磁盘臂移动到适当的柱面上所需的时间）。
- 2）旋转延迟（等待适当扇区旋转到磁头下所需的时间）。
- 3）实际数据传输时间。

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

###### 先来先服务（First-Come, First-Served, FCFS）

定义：磁盘驱动程序每次接受一个请求并按照接受顺序完成请求。

优点是简单和公平。缺点是很难优化寻道时间，磁头移动的距离和平均距离可能很大。

###### 最短寻道优先（Shortest Seek First，SSF）

定义：下一次总是处理与磁头距离最近的请求以使寻道时间最小化。

虽然得到最小响应时间，但缺乏公平性。当磁盘负载很重时，可能会使磁头一直停留在磁盘某区域，远离该区域的请求很难得到响应，直至该区域无请求为止。

###### 电梯算法（SCAN）

定义：与电梯运行一样，保持按一个方向移动，直到那个方向上没有请求为止，然后才改变方向。

电梯算法的一个优点是，对任意一组请求，磁盘臂移动总次数上界均为柱面数的两倍。

###### 循环扫描算法（SCAN）

定义：总是按一个方向扫描，当处理完请求的最高编号柱面后，立即回到未完成请求的最低编号柱面，然后继续沿该方向移动。

该方法相对于电梯算法在响应时间上具有更小的变异。

#### 静态链接与动态链接

链接（linking）是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件能被加载到内存并执行。

##### 编译器驱动程序

Unix系统上，从源文件到目标文件的转化由编译器驱动程序完成：
`linux> gcc -o hello hello.c`
    
执行编译过程的预处理器、编译器、汇编器和链接器构成了编译系统。

- 预处理阶段：预处理器（cpp）处理#开头的命令，生成hello.i文件。
- 编译阶段：编译器（ccl）将hello.i翻译成hello.s汇编文件。
- 汇编阶段：汇编器（as）将hello.s翻译成机器语言指令，存于可重定向目标文件hello.o中。
- 链接阶段：链接器将hello.o和标准C库中的printf.o合并，生成可执行目标文件hello。

##### 静态链接

静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件作为输出。

链接器完成两个主要任务：
- 符号解析：每个符号对应一个函数、全局变量或静态变量。符号解析的目的是将每个符号引用和一个符号的定义关联起来。
- 重定位：链接器把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

##### 目标文件

- 可重定位目标文件：可在编译时与其他可重定位目标文件合并，创建一个可执行目标文件。
- 可执行目标文件：可被直接复制到内存并执行。
- 共享目标文件：可在加载或者运行时被动态地加载进内存并链接。

##### 动态链接

静态链接的缺点：
- 和软件一样需要定期维护和更新。
- 一些标准库中的函数几乎存在于每个程序中，多进程运行时需要分别复制一遍到内存中，是对内存的极大浪费。

共享库（shared library）是一个目标模块，在运行和加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程叫动态链接（dynamic linking），由动态链接器（dynamic linker）执行。

共享库在Linux中用.so后缀表示，在Windows中称为DLL（动态链接库）。

共享库以两种方式来“共享”：
- 在任何给定的文件系统中，一个库只有一个.so文件。所有引用该库的可执行文件共享这个.so文件中的代码和数据，不像静态库那样将内容复制和嵌入到可执行文件中。
- 在内存中，一个共享库的.text节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

### Linux

#### 文件系统

- 从文件系统的角度分析数据恢复原理

##### inode

`ls -i`查看inode编号

###### 记录文件属性和block编号，一个文件占一个inode

`ls -l`查看的属性

##### block

###### 记录文件内容，一个文件会占多个block

##### 目录

###### 一个inode与至少一个block

###### block记录目录下文件的inode编号和文件名

###### 文件的 inode 本身不记录文件名

##### 文件读取

###### 根据inode查找block，再从block中读数据

#### 硬链接与软链接

`ln [-sf] source_filename dist_filename`
-s ：默认是实体链接，加 -s 为符号链接
-f ：如果目标文件存在时，先删除目标文件

##### 硬链接（实体链接）

###### 与源文件相同inode, 不同文件名

###### 删除后，文件只要引用数不为0仍存在

###### 不能跨越文件系统

###### 不能对目录链接

##### 软链接（符号链接）

###### 不同inode，保存源文件所在绝对路径

###### 源文件删除后，链接打不开

###### 可对目录链接

###### 类似Windows的快捷方式

#### 常用命令

- 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。

##### Linux缓冲机制

###### buffers和cached

`free`命令查看


####### buffers(缓冲)是即将被写入磁盘的数据

######## 减少磁盘碎片和寻道

####### cached(缓存)是从磁盘中读出的数据

######## 减少磁盘I/O，提高效率

#### 僵尸进程与孤儿进程

- 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。

##### SIGCHLD信号

###### 子进程状态改变时会发送给父进程

###### 包含子进程的信息

##### wait()和waitpid()

###### 接收SIGCHLD信号，销毁子进程并返回

###### 父进程调用阻塞，waitpid()可设为非阻塞

##### 孤儿进程

###### 父进程退出，子进程还在运行

###### 会被init进程收养并释放，对系统无害

##### 僵尸进程

###### 子进程退出，父进程没调用wait(), 子进程描述符仍存在

###### 会导致系统不产生新进程

###### 杀死父进程，使其变孤儿进程

## 网络

<!--Note-->
### 资料

- 《计算机网络 自顶向下方法》
- 《计算机网络》
- 《TCP/IP 详解 卷 1：协议》
- 《UNIX 网络编程 卷 1：套接字联网 API》
- 《Linux 多线程服务端编程》
- 《图解 HTTP》
<!--/Note-->

### 基础

- [计算机网络](https://cyc2018.github.io/CS-Notes/#/notes/计算机网络)

#### 体系结构

##### OSI七层协议

##### TCP/IP四层协议

##### 五层协议

###### 应用层

####### 数据传输服务对象

######## 特定应用程序

####### 协议

######## DNS，HTTP，SMTP

####### 数据单元

######## 报文

###### 运输层

####### 数据传输服务对象

######## 进程

####### 数据单元

######## 报文段，用户数据报

####### 协议 

######## TCP，UDP

###### 网络层

####### 数据传输服务对象

######## 主机

####### 数据单元

######## 分组

####### 协议

######## ARP，ICMP

###### 数据链路层

####### 数据传输服务对象

######## 同一链路的主机

####### 数据单元

######## 帧

####### 协议

######## PPP

######### 一对一，如用户与ISP

######### 点对点信道

######## CSMA/CD

######### 载波监听多点接入/碰撞检测

######### 广播信道

####### 三个基本问题

######## 封装成帧

######### 分组加首部和尾部

######## 透明传输

######### 转义字符转义首部、尾部和自身

######## 差错检测

######### 循环冗余检验（CRC）

###### 物理层

####### 透明传送传输比特流，屏蔽传输介质和物理设备差异

####### 数据单元

######## 比特

####### 信道复用技术

######## 时分复用

######## 统计时分复用

######## 频分复用

######## 波分复用

######## 码分复用

##### 图

######  

#### 以太网

##### 局域网是广播信道，分星型，环形和总线型

##### 以太网是星型结构局域网

#### 网络硬件设备

- 集线器、交换机、路由器的作用，以及所属的网络层。

##### 集线器

###### 物理层设备

###### 功能

####### 放大比特能量，扩大传输距离

####### 会发生碰撞

##### 交换机

###### 链路层设备

###### 功能

####### 自学习能力，即插即用

####### 交换表：MAC地址 - 接口

##### 路由器

###### 分组发送

####### 路由表：目的网络 - 下一跳

####### 根据网络地址，选择直接交付、下一跳路由器和默认路由器

###### 路由选择协议

随通信量和拓扑结构自适应调整

####### 自治系统AS

######## 使用相同路由选择协议

####### 内部网关协议

######## RIP

######### 距离向量算法

##########  

######## OSPF

######### 最短路径算法

####### 外部网关协议

######## BGR

#### IP 数据报

##### 格式

######  

##### 片偏移

######  

#### ARP 协议

##### ARP请求分组，ARP响应分组

##### ARP高速缓存: IP地址 - MAC地址

#### ICMP 协议

##### 询问报文 

###### Ping

####### 发送Echo请求报文，返回Echo回答报文

##### 差错报告报文

###### Traceroute

####### 发送无法交付的UDP，TTL从1开始，中间路由返回时间超过，目的主机返回终点不可达。

#### UDP 与 TCP

##### 传输控制协议TCP

###### 面向连接、可靠交付、面向字节流、点对点

###### 首部格式

#######  

###### 文件传输、发送和接收邮件、远程登录等场景。

##### 用户数据报协议UDP

###### 无连接、尽最大可能交付、面向报文、广播或多播

###### 首部格式

#######  

###### QQ 语音、 QQ 视频 、直播等等

#####  

#### TCP 连接

- 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。

##### TCP三次握手

###### 图

#######  

###### 三次握手原因

####### 防止服务器打开已经失效连接

####### 确保对方发送接收正常

######## 第一次握手，服务器只确定客户端发送正常

######## 第二次握手，客户端确定服务端发送、接收正常，建立连接

######## 第三次握手，服务端确定客户端发送、接收正常，建立连接

##### TCP四次挥手

###### 图

#######  

###### 四次挥手原因

####### 第二次握手，防止客户端FIN报文超时重发

####### 第三次握手，表示服务端数据发送完毕，可以断开连接了

###### TIME_WAIT

####### 确保最后一个确认报文到达，服务端不超时重发

####### 2MSL内所有报文消失，防止影响下次连接

MSL为报文最长生存时间。

######## ACK报文到达时间<MSL，重发FIN报文到时时间<MSL，故最长TIME_WAIT < 2MSL

#### TCP 可靠传输

- 设计可靠 UDP 协议

##### 数据分片和排序

##### 校验和

###### 首部中有首部和数据的检验和

##### 超时重传

###### 已发数据包在超时时间内没收到确认会重传

##### 流量控制

###### 滑动窗口

#######  

###### 流量控制

####### 控制发送方速率，使接收方来得及接收

####### 发送窗口 <= 接收窗口

##### 拥塞控制

#### TCP 拥塞控制

##### 慢开始和拥塞避免

cwnd随传输轮次的变化，每过一个往返时间RTT就算一轮。

###### 慢开始

####### 从cwnd = 1开始，cwnd指数增长

###### 拥塞避免

####### 当cwnd >= ssthresh，cwnd线性增长

###### 出现超时，令ssthresh = cwnd / 2, 重新执行慢开始

##### 快重传和快恢复 

###### 快重传

####### 丢失M3报文段，收到3个M2重复确认，立即快重传M3

########  

###### 快恢复

####### 快重传时，令 ssthresh = cwnd / 2 ，cwnd = ssthresh

#####  

######  

#### DNS

DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。

##### 大多用UDP传输，也可TCP传输，端口号53

##### DNS查询

###### 分支主题

######  

##### 域名服务器和本机中都有使用高速缓存

### HTTP

- [HTTP](https://cyc2018.github.io/CS-Notes/#/notes/HTTP)

#### GET 与 POST

##### 作用

###### GET获取资源

###### POST传输实体主体

##### 参数

###### GET参数出现在URL中，URL只支持ASCII码，中文等参数需要编码。

###### POST参数存储在实体主体中，支持标准字符集。

##### 数据大小

###### GET受URL长度限制

###### POST不受限制

##### 安全

###### 安全方法

不修改服务器的数据


####### 安全: GET, HEAD, OPTIONS

####### 不安全: POST, PUT, DELETE

###### 数据安全性

####### POST的安全性比GET高

##### 幂等性

幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。

###### 幂等：GET, HEAD, PUT, DELETE

###### 不幂等：POST

##### 可缓存

###### 请求报文的HTTP方法

####### GET、HEAD可缓存，PUT、DELETE不可缓存，POST多数情况不可缓存

###### 响应报文的状态码

####### 都可缓存

###### 响应报文的Cache-Control可指定缓存

#### 状态码

##### 1XX 信息

###### 100 Continue

####### 目前为止都正常，继续

##### 2XX 成功

###### 200 OK

###### 204 No Content

####### 返回响应报文不含实体主体

###### 206 Partial Content

####### 响应范围请求成功

##### 3XX 重定向

###### 301 Moved Permanently

####### 请求资源已永久移到新位置

###### 302 Found

####### 请求资源临时从不同URI响应

###### 303 See Other

####### 同302，但要求GET方法

###### 304 Not Modified

####### 带条件的请求被允许，但无满足条件资源

###### 307 Temporary Redirect

####### 同302，但禁止POST改成GET

##### 4XX 客户端错误

###### 400 Bad Request

####### 请求报文中存在语法错误

###### 401 Unauthorized

####### 请求需要用户认证或认证失败

###### 403 Forbidden

####### 请求被拒绝

###### 404 Not Found

##### 5XX 服务器错误

###### 500 Internal Server Error

####### 服务器执行请求时发生错误

###### 503 Service Unavailable

####### 服务器暂处于超负荷或停机维护

#### Cookie

##### Cookie

###### 用户信息保存在客户端

###### 响应报文的Set-Cookie，请求报文的Cookie

##### Session

###### 用户信息保存在服务端

###### Session可存储在服务器的文件、数据库或内存中

###### 生成键Session ID

####### 通过Cookie传递Session ID

####### Cookie被禁用时使用URL重写技术传递Session ID

##### 用途

###### 会话状态管理（登录状态，购物车等）

###### 个性化设置（自定义设置，主题等）

###### 浏览器行为追踪（分析用户行为等）

##### 选择

###### Cookie值存储ASCII码，Session可存储任何类型

###### Session安全性更高，隐私数据在Cookie中需要加密

###### 大型网站不宜使用Session

#### 缓存

- [Expires 和 max-age 的区别](https://www.cnblogs.com/yinhaiming/articles/1490811.html)
- [Expires vs max-age, which one takes priority if both are declared in a HTTP response?
](https://stackoverflow.com/questions/7549177/expires-vs-max-age-which-one-takes-priority-if-both-are-declared-in-a-http-resp)

##### 优点

###### 缓解服务器压力

###### 降低客户端获取资源的延迟

##### 实现方法

###### 代理服务器进行缓存

###### 客户端浏览器进行缓存

##### Cache-Control

###### 不使用与不存储

####### no-cache

######## 强制向源服务器验证再次验证

####### no-store

######## 不缓存任何内容

###### 公有与私有

####### public

######## 可被多个用户使用，存于代理服务器中

####### private

######## 只被单独用户使用，存于浏览器中

###### 过期机制

####### max-age

######## 请求报文，响应缓存的age需小于指定时间

######## 响应报文，缓存资源在服务器中的保存时间

####### expires

######## 缓存资源过期时间

####### HTTP/1.1中优先处理max-age，HTTP/1.0中忽略max-age

##### 缓存验证

###### ETag

####### 资源唯一标识

###### 缓存的ETag放入If-Node-Match，验证缓存是否有效

###### 响应的Last-Modified指示资源的最后修改时间，后续请求带上 If-Modified-Since 来验证缓存

#### 连接管理

##### 长连接

###### 一次TCP连接，多次HTTP通信

###### HTTP/1.1开始默认长连接

###### 连接时响应头包含Connection : keep-alive, 断开时，使用Connection : close

##### 短连接

###### 一次TCP连接，一次HTTP通信

###### HTTP/1.0默认短连接

##### 流水线

###### 长连接上连续发送请求，无需等待响应

###### 减少延迟

#####  

######  

#### HTTPS

让HTTP先与SSL通信，再由SSL和TCP通信，即使用隧道通信。

##### 缺点

###### HTTP

####### 明文通信，可被窃听

####### 不验证通信方身份，可被伪装

####### 无法证明报文完整性，可被篡改

###### HTTPS

####### 因为需要加密和解密，速度更慢

####### 需要支付证书授权的高额费用

##### 加密（防窃听）

###### 对称密钥加密（共享密钥加密）

####### 加密和解密使用同一密钥

####### 优点：运算速度快

####### 缺点：无法安全将密钥传给通信方

#######  

########  

###### 非对称密钥加密（公开密钥加密）

####### 加密和解密使用不同密钥

####### 发送方使用接受方公开密钥加密，接收方使用私有密钥解密

####### 优点：可安全将公开密钥传给发送方

####### 缺点：运算速度慢

###### HTTPS混合加密机制

####### 保证安全性

######## 使用非对称密钥加密方式加密对称密钥加密方式的密钥

####### 保证效率

######## 使用对称密钥加密方式进行通信

#######  

########  

##### 认证（防伪装）

###### 数字签名

####### 避免数据在传输过程中被替换

########  

###### 数字证书

####### 数字证书认证机构CA保证公开密钥在传输过程中不被替换 

####### CA对公开密钥做数字签名，已签名密钥放入证书

########  

##### 完整性保护（防篡改）

###### SSL 提供报文摘要功能来进行完整性保护。

###### HTTP 也提供了 MD5 报文摘要功能，但HTTPS的加密和认证保证不被篡改

#### HTTP/2

##### 二进制分帧层

###### 报文分HEADERS帧和DATA帧，都是二进制格式

#######  

###### 通信只用一个TCP连接，承载任意数量双向数据流（Stream）

#######  

##### 服务器推送

###### 客户端请求一个资源，会自动将相关资源一起发送

#######  

##### 首部压缩

###### 维护和更新一个首部字段表，避免传输重复字段，并编码进行压缩 

#######  

##### 多路复用

#### HTTP1.1新特性 

##### 默认长连接，支持流水线

##### 新增更多的缓存控制策略

###### max-age，If-Match, If-None-Match

##### 新增多个状态响应码

###### 100

##### 新增Host头字段，支持虚拟主机（一台服务器多个域名）

##### 新增range头字段，支持断点续传

#### HTTP 与 FTP

### Socket

- [Socket](https://cyc2018.github.io/CS-Notes/#/notes/Socket)

#### I/O 模型

##### IO操作两阶段

###### 等待数据准备好

###### 数据从内核拷贝到进程中

IO中数据先拷贝到内核缓冲区，再从缓冲区拷贝到应用程序地址空间。

##### 5种I/O 模型

###### 阻塞式I/O

####### 1、2阶段都阻塞，CPU利用率高

###### 非阻塞式I/O

####### 1阶段轮询，2阶段阻塞，CPU利用率低

###### I/O复用

####### 1阶段阻塞在select，2阶段阻塞，多连接时开销小

###### 信号驱动I/O

####### 1阶段非阻塞，2阶段阻塞，CPU利用率高

###### 异步I/O

####### 1、2阶段都非阻塞

##### 阻塞与非阻塞

###### 1阶段

##### 同步与异步

###### 2阶段

#### 多路复用

##### select

```
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```


###### fd_set数组

####### 下标对应文件描述符 fd

####### 值为1监视，为0不监视

###### readset、writeset、exceptset 对应监视读、写、异常的fd_set数组

###### timeout

####### select阻塞超时时间

###### 调用

####### fd_set中有变动的保持1，无变动的置0

####### 成功返回大于0，出错返回-1，超时返回0

##### poll

```
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

###### fd 数量没限制，select限制为1024

##### epoll

仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项

###### epoll_create

####### 创建 fd 数组

###### epoll_ctl

####### 向内核注册或更改 fd

###### epoll_wait

####### 从内核返回发生变化 fd

###### 优点

####### fd 从进程向内核缓冲区只拷贝一次， select 每次调用都拷贝

####### 没 fd 数量限制

####### 只需遍历就绪的 fd， select 遍历所有 fd

###### 工作模式

####### LT（Level Trigger）

######## 只要缓冲区有数据就会一直通知该事件

####### ET（Edge Trigger）

######## 事件只通知一次，即使缓冲区还留该数据也不再通知

######## 可等数据顺序收齐后再通知，效率比 LT 高

#### Java NIO

## 数据库

<!--Note-->
### 资料

- 《MySQL 必知必会》
- [Leetcode](https://leetcode.com/problemset/database/)
- 《高性能 MySQL》
- 《MySQL 技术内幕》
- 《Redis 设计与实现》
- 《Redis 实战》
- 《大规模分布式存储系统》
<!--/Note-->

### SQL

#### 手写分组查询

#### 手写连接查询

#### 连接与子查询

#### drop、delete、truncate

#### 视图

- 视图的作用，以及何时能更新视图。

#### 存储过程

#### 触发器

### 系统原理

#### 事务

##### ACID

###### 原子性（atomicity）

事务的所有操作在数据库中要么全部正确反映出来，要么完全不反映。

如果事务没能完成它的执行，数据库系统从日志中恢复旧值，使得看上去事务从未执行过。

###### 一致性（consistency）

如果一个事务作为原子从一个一致的数据库状态开始独立地执行，则事务结束时数据库也必须再次是一致的。

例如，一致性要求转账过程中事务的执行A账户、B账户之和不变。

###### 隔离性（isolation）

数据库必行采取特殊处理来确保事务正常执行而不被来自并发执行的数据库语句所干扰。

事务的隔离性确保事务并发执行后的系统状态和这些事务以某种次序一个接一个地执行后的状态是等价的。

###### 持久性（durability）

一个事务完成后，它对数据库的改变必须是永久的，即使出现系统故障。

确保事务做的更新在事务结束前已经写入磁盘或有关事务已执行的更新信息已写到磁盘上。

##### 隔离级别

四大隔离级别，以及不可重复读和幻影读的出现原因。

###### 可串行化（serializable）

解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。

###### 可重复读（repeatable read）

禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。

###### 已提交读（read committed）

解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。

###### 未提交读（read uncommitted）

解决更新丢失问题。如果一个事务已经开始写操作，那么其他事务则不允许同时进行写操作，但允许其他事务读此行数据。该隔离级别可以通过“排他写锁”实现，即事物需要对某些数据进行修改必须对这些数据加 X 锁，读数据不需要加 S 锁。

#### 封锁

封锁的类型以及粒度，两段锁协议，隐式和显示锁定。

##### 锁的类型

###### 读写锁

- 共享型锁（shared-mode lock）：又称读锁，记为S，事务可读但不能写数据项。
- 排他型锁（exclusive-mode lock）：又称写锁，记为X，事务既可读又可写数据项。

如果事务 T1 在数据项 Q 上已加 B 型锁，事务 T2 要对数据项 Q 加 A 型锁，若事务 T2 可立即获得数据项 Q 上的锁，则 A 型锁与 B 型锁是相容的（compatible）。

锁的相容性矩阵comp：

- |   S   |   X 
- |   -   |   -
S | true  | false
X | false | false

- 如果不使用封锁，或者对数据项进行读写后立即解锁，可能会进入不一致的状态。
- 如果在申请对另一数据项加锁之前不对当前锁住的数据项解锁，则可能会发生死锁。
- 产生死锁显然比产生不一致状态要好，因为可以通过回滚事务加以解决。

# InnoDB 存储引擎
S 和 X 锁都是行锁，即对一行数据进行操作。

###### 意向锁

事务要封锁整个数据库时，需要在不搜索整棵树的情况下知道树的某部分是否持有锁。

**意向锁类型（intention lock mode）**：一个结点显示加锁之前，会在遍历树的过程中给该结点的全部祖先结点均加上意向锁。

- **共享型意向（intention-shared（IS）mode）锁**：将在树的较低层显式地加共享锁。
- **排他型意向（intention-exclusive(IX）mode）锁**：将在树的较低层显示地加排他锁或共享锁。
- **共享排他型意向锁（shared and intention-exclusive（SIX）mode）**：在子树显示地加了共享锁，并且将在树的更底层显示地加排他锁。

意向锁类型的相容性矩阵：

-  |IS   |IX   |S    |SIX  |X
-  |-    |-    |-    |-    |-
IS |true |true |true |true |false
IX |true |true |false|false|false
S  |true |false|true |false|false
SIX|true |false|false|false|false
X  |false|false|false|false|false

# InnoDB 存储引擎
- 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。
- 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。

InnoDB中意向锁为表锁，没有共享排他型意向锁（SIX Lock）。


##### 两阶段封锁协议（tow-phase locking protocol）

**增长阶段（growing phase）**：事务可以获得锁，但不能释放锁。
**缩减阶段（shrinking phase）**：事务可以释放锁，但不能获得新锁。

最初，事务处于增长阶段，可加锁。事务一旦解锁，就进入缩减阶段，不能再加锁。

两阶段封锁协议保证冲突可串行化，但并不保证不会发生死锁。


##### 多粒度

如果事务需要访问整个数据库，对数据库中的每个数据项加锁是很费时的，只发单个封锁整个数据库的加锁请求会更好。另一方面，如果事务只需存取少量数据项，就不应要求整个数据库加锁，否则将丧失并发性。因此，定义了**多级粒度（granularity）**机制。

##### 锁的算法

Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。

MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。


###### Record Lock

锁定一个记录上的索引，而不是记录本身。

如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Lock 总是会去锁住记录。

###### Gap Lock

锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。
```
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

####### 只在Repeatable read 隔离级别下

####### 防止幻读

###### Next-Key Lock

它是 Record Lock 和 Gap Lock 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙，是一个前开后闭区间。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：
```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +supremum)
```

当查询的列是唯一索引时，InnoDB会将Next-Key Lock降级为Record Lock，即仅锁住索引本身，而不是范围。

##### 锁问题

###### Dirty Read（脏读）

脏读是指当前事务读到其他事务未提交的数据。

脏读发生的条件需要事务的隔离级别为READ UNCOMMITTED。

#######  

T1 修改一个数据，T2 随后读取这个数据。如果 T1 回滚了这次修改，那么 T2 读取的数据是脏数据。

###### 不可重复读

不可重复读是指一个事务多次读取同一数据可能不一样。

不可重复读和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的是已提交的数据。

在InnoDB存储引擎中通过使用 Next-Key Lock 算法来避免不可重复读的问题。

#######  

T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

###### 丢失更新

丢失更新是指一个事务的更新操作会被另一个事务的更新操作所覆盖，导致数据不一致。

#######  

T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

###### 幻影

T1 在未提交前连续两次读取某个范围的数据，而T2在此期间在该范围内插入新的数据，导致T1 连续两次读取的结果不一样。

产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。InnoDB在REPEATABLE READ事务隔离级别下，采用Next-Key Locking的方式来加锁。在READ COMMITTED下, 仅采用Record Lock。

####### 图

########  

####### 解决

######## 可串行化隔离级别

######## MVCC + next-key locks

#### 乐观锁与悲观锁

#### MVCC 

#### 范式

##### 规范化

关系模式中存在的问题：
- **数据冗余**：数据重复出现，浪费大量的存储空间
- **更新异常（Update Anomalies）**：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。
- **插入异常（Insertion Anomalies）**：如果一个学生函数依赖于系，则无法把一个刚成立、尚无学生的系的信息存入数据库。
- **删除异常（Deletion Anomalies）**：删除一个信息，那么也会丢失其它信息。

规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。

一个低一级范式的关系模式，通过**模式分解（schema decomposition）** 可以转换为若干个高一级范式的关系模式的集合，这种过程就叫**规范化（normalization）**。

满足最低要求的叫第一范式1NF。

###### 第一范式(1NF)

关系模式{Sno序号 Sname学生, Sdept学院, Mname院长, Cname课程, Grade分数}

{Sno, Cname} 为主键

函数依赖：
- Sno -> Sname, Sdept （部分依赖）
- Sdept -> Mname （传递依赖）
- Sno, Cname-> Grade （完全依赖）

####### 属性不可分。

###### 第二范式(2NF) 

根据第二范式分解后：

关系1 {Son, Sname, Sdept, Mname}
- Sno -> Sname, Sdept （完全依赖）
- Sdept -> Mname （传递依赖）

关系2 {Sno, Cname, Grade}
- Sno, Cname -> Grade （完全依赖）

####### 每个非主属性完全函数依赖于键码。

####### 消除部分依赖

###### 第三范式(3NF)

关系1根据第三范式分解：

关系-11{Sno, Sname, Sdept}
- Sno -> Sname, Sdept （完全依赖）

关系-12{Sdept, Mname}
- Sdept -> Mname （完全依赖）


####### 非主属性不传递函数依赖于键码。

####### 消除传递依赖

#### SQL 与 NoSQL

### MySQL

#### B+ 树

- 大规模数据存储中，实现索引查询这样一个实际背景下，**磁盘查找存取的次数往往由树的高度所决定**，二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率。

- B树与红黑树最大的不同在于，B树的结点可以有许多孩子，从几个到几千个。B树与红黑树很相似，一棵含n个结点的B树的高度也为O（logn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。


[从B树、B+树、B*树谈到R 树](https://blog.csdn.net/v_JULY_v/article/details/6530142)





##### B树

<!--Note-->
####### B树
B树（B-tree）是一种平衡的多路查找树，结点最大的孩子数目称为B树的阶。
一个m阶的B树具有如下属性：
- 如果根结点不是叶结点，则其至少有两个孩子（子树）。
- 每个非根的分支结点都有k-1个元素和k个孩子，每个叶子结点n都有k-1个元素，其中⌈m/2⌉<=k<= m。
- 所有叶子结点都位于同一层次。
- 所有分支结点包含下列信息数据（n,A₀,K₁,A₁,K₂,A₂,...,Kₙ,Aₙ），其中：
	- Kᵢ(i=1,2,...,n)为关键字，且Kᵢ<Kᵢ₊₁;
    - Aᵢ(i=0,2,...,n)为指向子树根结点的指针，且指针Aᵢ所指子树中所有结点的关键字均小于Kᵢ₊₁，但都大于Kᵢ;
    - 关键字的个数必须满足：n(⌈m/2⌉-1<=n<= m-1)。

对于n个关键字的m阶B树，树的高度*h<= log⌈m/2⌉((n+1)/2)+1*。
<!--/Note-->

###### 图为3阶B树，结点结构为（2,A₀,K₁,A₁,K₂,A₂） 

##### B+树

<!--Note-->
####### B+树
一个m阶的B+树和m阶的B树的差异在于：
- 有n棵子树的结点中包含n个关键字；
- 所有的叶子结点包含全部关键字的信息，及指向含有这些关键字记录的指针，叶子结点本身依关键字的大小自小到大顺序链接；
- 所有分支结点可以看成是索引，结点中仅含有其子树中的最大（或最小）关键字。

B+树相较于B树的优点：
- **B+-tree的磁盘读写代价更低**：B+-tree的内部结点并没有指向关键字具体信息的指针。
- **B+-tree的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路，导致每一个数据的查询效率相当。
<!--/Note-->

######  

######  

#### 索引以及优化

##### 特点

###### 优点

####### 提高检索速度

######## B+树查找代替遍历双向链表

####### 随机 I / O 变顺序 I / O

######## 减少磁盘寻道

####### 帮助服务器避免排序和临时表

####### 减少服务器扫描数据量

###### 缺点

####### 占物理空间

####### 降低增删改速度

######## 要维护B+树平衡

##### 哈希索引

把键值换算成新的哈希值，根据这个哈希值来定位

###### 无法排序

###### 只含哈希值和行指针，不存字段值

###### 联合索引 (a, b) 全部列计算哈希值，不能只查询a

###### 只支持等值比较，不支持范围查询

###### 速度快，但哈希冲突多时维护代价高

###### InnoBD使用自适应哈希索引

在B+树上给频繁索引值加哈希索引。

##### 最左匹配原则

最左开始匹配连续索引，直至范围查询。

###### 联合索引 (a, b), 最左字段构建B+树，a全局有序，b局部有序，若a值是一个范围，范围内b不一定有序

###### 无需考虑 =、in 顺序，mysql自动优化

##### 索引策略

###### InnoBD的聚簇索引

####### 主键创建的索引

####### 叶子节点 -> 表中行数据

###### 非聚簇索引

####### InnoBD的二级索引

######## 非主键创建的索引

######## 叶子节点 -> 主键值 + 索引列值

####### MyISAM的索引

######## 主键或非主键创建

######## 叶子节点 -> 行指针 + 索引列值 

###### 覆盖索引

```

select username , age 
from user 
where username = 'Java3y' 
and age = 20;
```

####### 查询的列与索引对应，二级索引无需回表

####### 把随机IO变成顺序IO加快查询效率 

##### 索引优化

###### 索引使用场合

####### where

####### order

####### join

####### 覆盖索引

###### 优化

####### 字段要独立存在

```
# 索引失效
select * from user where id+1 = 20; 
```
```
# 索引有效
select * from user where id = 20-1;
```


####### like，不能以通配符%开头

```
 # 索引失效
select * from article where title like '%mysql%';
```
```
 # 索引有效
select * from article where title like 'mysql%';
```

####### 联合索引注意最左匹配原则

####### or, 需要两边条件都有索引

####### 不要在索引列上进行计算

#### 查询优化

##### explain 分析 select 

###### select_type

####### 查询类型，有简单查询、联合查询、子查询等

###### key

####### 使用的索引

###### rows

####### 扫描的行数

###### possible_keys

####### 可选的索引

##### 优化数据访问

###### 只返回必要行：最好不要使用 SELECT *

###### 只返回必要列：使用LIMIT限制 

###### 缓存重复查询的数据

###### 使用覆盖索引查询

#### InnoDB 与 MyISAM

#### 水平切分与垂直切分

#### 主从复制

#### 日志

### Redis

#### 字典和跳跃表

#### 使用场景

#### 与 Memchached 的比较

#### RDB 和 AOF 持久化机制

#### 数据淘汰机制

#### 事件驱动模型

#### 主从复制

#### 集群与分布式

#### 事务

#### 线程安全问题

## 面向对象

<!--Note-->
### 资料

- 《Head First 设计模式》
<!--/Note-->

### 思想

#### 三大特性

#### 设计原则

### 设计模式

#### 单例模式

手写单例模式，特别是双重检验锁以及静态内部类。

##### 定义

###### 一个实例，全局访问点

##### 结构

###### 私有构造函数

`private Singleton() {};`

###### 私有静态变量

`private static Singleton uniqueInstance;`

###### 公有静态函数

`public static Singleton getUniqueInstance(){}`

##### 懒汉式

###### 线程不安全

####### 使用时创建

###### 线程安全

####### synchronized修饰方法

###### 双重校验锁

```
public class Singleton {
	private volatile static Singleton uniqueInstance;
    
    private Singleton () {
    }

	public static Singleton getUniqueInstance() {
    	if (uniqueInstance == null) {
        	synchronized(Singleton.class) {
            	if (uniqueInstance == null) {
                	uniqueInstance = new Singleton();
                }
            }
    	}
    	return uniqueInstance;
    }
}
```

####### volatile可见性和禁止指令重排序

###### 静态内部类

```
public class Singleton {
	private static class SingletonHolder {
    	private static final Singleton INSTANCE = new Singleton();
    }
    
    private Singleton () {
    }
    
    public static Singleton getUniqueInstance () {
    	return SingletonHolder.INSTANCE;
    }
}
```

####### 静态内部类被调用才加载

##### 饿汉式

###### 线程安全

####### 加载时创建

###### 枚举

```
public enum Singleton {
    INSTANCE;  
}
```

####### 反射和序列化都不破坏单例

#### 工厂模式

手写工厂模式。


##### why

###### 解耦

####### 对象创建和使用分开

###### 降低代码重复

####### 某些类创建过程复杂

###### 降低维护成本

####### 直接工厂里修改

##### 简单工厂

```
public class SimpleFactory {
	public Gun produceGun(int type) {
    	if (type == 1) {
        	return new AK();
        } else {
        	return new M4A1();
        }
    }   
}
```

###### 违背 (扩展)开发-(修改)封闭原则，反射可改善

##### 工厂方法

```
public interface Factory {
	public Gun produceGun();
}
```
```
public class AK_Factory implements Factory {
	@Override
	public Gun produceGun() {
    	return new AK();
    }   
}
```
```
public class M4A1_Factory implements Factory {
	@Override
	public Gun produceGun() {
    	return new M4A1();
    }   
}
```

###### 创建单一对象

##### 抽象工厂

```
public interface Factory {
	public Gun produceGun();
    public Bullet produceBullet();
}
```
```
public class AK_Factory implements Factory {
	@Override
	public Gun produceGun() {
    	return new AK();
    }   
    
    @Override
	public Bullet produceBullet() {
    	return new AK_Bullet();
    } 
}
```
```
public class M4A1_Factory implements Factory {
	@Override
	public Gun produceGun() {
    	return new M4A1();
    }   
    
    @Override
	public Bullet produceBullet() {
    	return new M4A1_Bullet();
    } 
}
```

###### 创建对象家族

#### MVC

理解 MVC，结合 SpringMVC 回答。

#### 代理模式

结合 Spring 中的 AOP 回答。

##### 动态代理

```
public static void main(String[] args) {
	// 代理对象
    Subject realSubject = new RealSubject();
    
    // 调用处理器实现类
    InvocationHandler handler = new InvocationHandlerImpl(realSubject);
    
    // 创建代理
    ClassLoader loader = realSubject.getClass().getClassLoader();
    Class[] interfaces = realSubject.getClass().getInterfaces();
    
    Subject subject = (Subject) Proxy.newProxyInstance(loader, interfaces, handler);
    
    subject.SayHello();
}
```

###### InvocationHandler接口

```
public object invoke(Object obj, Method method, Object[] args);
```

###### Proxy类

```
static Object newProxyInstance(ClassLoader loader, Class[] interfaces,  InvocationHandler h);
```

#### JDK 中常用的设计模式

例如装饰者模式、适配器模式、迭代器模式等。

##### 结构型

###### 桥接

####### 将抽象类中的实现部分分离

```
Abstraction abstraction = new RefinedAbstraction(new ConcreteImplementor());
```

###### 适配器

####### HDMI hdmi = new Adapter(new VGA());

##### 创建型

###### 建造者模式

####### 组装复杂的实例

###### 原型模式

####### 通过复制生成实例

## Java

<!--Note-->
### 资料

- 《JAVA 核心技术》
- 《Java 编程思想》
- 《Effective java 中文版》
- 《深入理解 Java 虚拟机》
- 《Java 并发编程实战》
- 《精通 Spring 4.x》
- 《Spring 揭秘》
<!--/Note-->

### 基础

- [Java 基础](https://cyc2018.github.io/CS-Notes/#/notes/Java%20基础)

### 虚拟机

- [Java 虚拟机](https://cyc2018.github.io/CS-Notes/#/notes/Java%20虚拟机)

#### 内存区域

##### 运行时数据区

###### 线程私有区域

####### 程序计数器

######## 当前线程所执行的字节码的行号指示器

######## 对于Java方法，记录正在执行的虚拟机字节码指令的地址；对于Native方法，则为空

######## 唯一无OutOfMemoryError异常的区域

####### Java虚拟机栈

######## 方法执行的内存模型

######### 每个方法执行时创建一个栈帧

######### 栈帧用于存储

########## 局部变量表

存放编译期可知的基本数据类型、对象引用、returnAddress类型。

########## 操作数栈

########## 动态链接

########## 方法出口

######### 方法的调用和完成对应栈帧在虚拟机栈中的出栈和入栈

######## 两种异常

######### StackOverflowError异常

########## 线程请求的栈深度大于虚拟机允许的深度

######### OutOfMemoryError异常

########## 若虚拟机栈可动态扩展，却无法申请到足够内存

########## HotSpot虚拟机无法动态扩展，故无此异常

####### 本地方法栈

######## 与虚拟机栈的作用非常相似，只不过本地方法栈是为Native方法服务

###### 线程共享区域

####### Java堆

######## Java虚拟机管理内存中最大的一块

######## 所有对象实例及其数组都在堆上分配内存

######## 垃圾收集器管理的主要区域（“GC堆”）

######## 无需连续内存空间，可动态扩展

######### -Xmx:JVM最大可用内存

######### -Xms:JVM初始化内存大小

######## OutOfMemoryError异常

######### 堆中没内存可分配且无法扩展

####### 方法区

######## 存储已被JVM加载的

######### 类信息

######### 常量

######### 静态变量

######### 即时编译后的代码

######## hotspot用永久代实现方法区

######### 为省去为方法区编写内存管理代码的工作

######### 容易遇到内存泄漏，极少数方法在不同虚拟机下有不同表现

######### JDK 7 将永久代中的字符串常量池、静态变量等移至Java堆

######### JDK 8 完全弃用永久代，将剩余内容（主要是类型变量）移至元空间

######## 无需连续内存，可扩展，可不实现垃圾收集

######## 内存回收的目标主要针对常量池的回收和对类型的卸载，但效果一般

######## OutOfMemoryError异常

######## 运行时常量池

######### Class文件常量池（存放编译期生成的字面量和符号引用）在类加载后放入该区域

######### 动态性

########## 除了编译期，运行期也可将新常量放入池中，如String类的intern()方法

###### 图

#######  

##### 直接内存

###### JDK 1.4引入NIO (New Input/Output) 类

####### 通道（Channel）与缓冲区（Buffer）

####### Native函数库 -> 堆外内存 -> Java堆中的DirectByteBuffer对象

####### 避免Java堆和Native堆来回复制数据

##### Java对象创建

###### 图

####### 分支主题

###### 类加载检查

####### new -> 检查常量池 -> 类加载

###### 分配内存

####### 分配方式

######## 指针碰撞

######### 用过和没用过内存各放一端，分界值指针

######### 场合：没内存碎片

######### GC收集器：Serial、ParNew

######## 空闲列表

######### 列表记录空闲内存

######### 场合：大量内存碎片

######### GC收集器：CMS

###### 初始化零值

###### 设置对象头

###### 执行init方法

#### 垃圾收集 GC

只针对Java堆和方法区。程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，当方法或线程结束时，内存随之回收，无需考虑回收问题。

##### 对象已死？

###### 判断方法

####### 引用计数法

######## 引用计数器，引用加1，失效减1，为0不再使用

######## 缺点

######### 循环引用，无法回收

```
public class ReferenceCountingGc {
    Object instance = null;
	public static void main(String[] args) {
		ReferenceCountingGc objA = new ReferenceCountingGc();
		ReferenceCountingGc objB = new ReferenceCountingGc();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;
	}
}
```

####### 可达性分析算法

######## 判读GC Roots到某对象是否引用链可达

######## 可做GC Roots的对象

######### 虚拟机栈中引用的对象

######### 方法区中类静态属性引用的对象

######### 方法区中常量引用的对象

######### 本地方法栈中JNI引用的对象

######### Java虚拟机内部的引用 

######### 被同步锁持有的对象

######### JMXBean、 JVMTI中注册的回调、 本地代码缓存

######## 图

#########  

###### 引用

####### 强引用

######## Object obj = new Object()

######## 引用在，不回收

####### 软引用

######## 有用但非必须的对象 

######## 将OOM前，把这些对象回收，若仍OOM，才抛出异常

######## SoftReference类实现

####### 弱引用

######## 非必须对象

######## 下一次GC则清除

######## WeakReference类实现

####### 虚引用

######## 仅为了回收时收到系统通知

######## PhantomReference类实现

###### 生存还是死亡

####### 可达性分析后标记一次，还需判定是否执行finalize()

####### 覆盖finalize()的对象可再被引用，实现自救

####### finalize()只被系统调用一次，因此自救只有一次

####### 尽量避免使用，try-finally等更好

###### 回收方法区

####### 方法区中进行GC的性价比较低

####### 回收内容

######## 废弃常量

######### 常量池中不再引用的字面量、符号引用

######## 不再使用的类

######### 该类的所有实例已被回收

######### 该类的类加载器已被回收

######### 对应的java.lang.Class对象没被反射引用

##### 垃圾收集算法

###### 分代收集

####### 收集器将Java堆分成不同区域，根据回收对象的年龄放入

####### 新生代

######## GC时大批对象死去 -> 复制算法

####### 老生代

######## 对象存活几率高，没额外空间分配担保 -> 标记-清除 或 标记-整理

####### 跨代引用

######## 若新生代存在跨代引用→存活晋升到老生代→跨代引用消除

######## 新生代上建立记忆集，标示出存在跨代引用的那一小块老年代

######## Minor GC 只将存在跨代引用的一小块老年代内存加入GC Roots扫描

###### 标记-清除

- 标记出所需回收对象，统一回收所有标记对象；
- 或标记存活的对象，统一回收所有未标记对象。

####### 回收后会合并相邻空闲分块 -> 空闲链表

####### 不足

######## 效率问题

######### 效率随对象增多而降低

######## 空间问题

######### 产生大量不连续的内存碎片

####### 图

########  

###### 复制

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

####### 内存分两块，存活对象复制到另一块，使用空间一次清理

####### 不足

######## 内存缩小一半，空间浪费太多

####### Appel式回收

新生代内存分为一大块Eden空间和两小块Survivor空间。GC时，将Eden和Survivor中存活对象复制到另一块Survivor中，最后清掉Eden和使用过的Survivor。

######## HotSpot虚拟机默认Eden和Survivor大小比例为 8 : 1 

######## Survivor空间不足时，依赖老生代进行分配担保

####### 图

########  

###### 标记-整理

标记过程与“标记-清除”一样，让所有存活对象向内存空间一端移动，然后直接清除边界以外内存。

####### 在老年代存在大量存活对象，移动时需暂停应用程序

####### 解决标记-清除算法存在空间碎片化问题会影响应用程序吞吐量

####### HotSpot虚拟机中

######## 关注吞吐量的Parallel Scavenge收集器基于标记-整理

######## 关注延迟的CMS收集器则是基于标记-清除

####### “和稀泥式”方案

######## 平时采用标记-清除，内存碎片化程度大时，采用一次标记-整理

####### 图

######## 

##### 垃圾收集器

###### 图

#######  

###### Serial收集器

####### 单线程收集器，GC时会暂停其他所有工作线程

####### 简单而高效

######## 内存受限环境，额外内存消耗最小

######## 单核CPU环境，没有线程交互开销，拥有最高单线程收集效率

####### 适用于运行在客户端环境下的虚拟机

####### 图

########  

###### ParNew收集器

####### Serial收集器的多线程并行版本

- 并行：多条GC线程并行工作，用户线程仍处于等待。
- 并发：用户线程与GC线程同时执行。

####### JDK 7之前，是运行在服务端模式下首选新生代收集器

####### 除Serial收集器以外，唯一能与CMS收集器配合工作

####### 单核CPU环境下比Serial收集器差，多核CPU环境才高效

####### 图

########  

###### Parallel Scavenge收集器

####### 与ParNew一样是并行收集的多线程收集器

####### 目标

######## Parallel Scavenge收集器：达到一个可控制的吞吐量

######## CMS等收集器：缩短垃圾收集时用户线程停顿时间

####### 吞吐量

######## 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)

######## 停顿时间短，适合需要用户交互、保证响应质量的程序

######## 高吞吐量，适合后台运算、无需太多交互的分析任务

####### 参数

######## -XX:MaxGCPauseMillis

######### 控制最大垃圾收集停顿时间

######## -XX:GCTimeRatio

######### 直接设置吞吐量大小

######## -XX:UseAdaptiveSizePolicy

######### 开启GC自适应调节策略

虚拟机动态调节参数以提供最合适的停顿时间或最大的吞吐量。

####### 图

########  

###### Serial Old收集器

####### Serial收集器的老年代版本，单线程，标记-整理算法

####### 供客户端模式下的HotSpot使用

####### 用途

######## JDK 5之前，与Parallel Scavenge收集器搭配使用

########  CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

####### 图

########  

###### Parallel Old收集器

####### Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法

####### 注重吞吐量或CPU资源稀缺的场合，优先考虑Parallel Scavenge加Parallel Old收集器

####### 图

########  

###### CMS收集器

####### 以获取最短回收停顿时间为目标

####### 基于标记-清除算法

初始标记、重新标记需要停顿，并发标记、并发清除与用户程序同时并发

######## 初始标记

######### 只标记GC Roots直接关联的对象

######## 并发标记

######### 从GC Roots直接关联对象开始遍历整个对象图

######## 重新标记

######### 修正并发标记期间，因用户程序运作导致的标记变动

######## 并发清除

######### 清掉标记阶段判断的已死亡对象

####### 三个缺点

######## 对处理器资源敏感

######### 并发阶段虽不会停顿，但会占用部分线程使吞吐率降低

######## 无法处理浮动垃圾

######### 浮动垃圾：GC并发阶段产生的垃圾，只能下次GC时清除

######### 因此CMS收集器需要预留足够空间供用户线程使用

######### 预留内存不足时会出现Concurrent Mode Failure，需启动Serial Old收集器重新GC

######## 产生大量空间碎片

######### 往往出现老年代有很多剩余空间却找不到足够大的连续空间，不得不提前触发Full GC

####### 图

########  

###### Garbage First收集器（JDK 9）

####### 应用

######## 面向服务端的GC

####### 特点

######## 可预测停顿时间模型 

######### 能指定M毫秒的时间片段内，GC时间不超过N毫秒

######## Region

######### Java堆分为多个大小相等的Region

######### 每个Region可扮演新生代的Eden、Survivor或老年代空间

######### Humongous Region

########## 专门存储大对象

大对象：大小超过一个Region容量一半的对象。

########## 超级大对象存储在连续的Humongous Region中

超级大对象：超过一个Region容量的对象。

########## 作为老年代的一部分

######### 单次回收的最小单元

########## 每次GC都是Region大小的整数倍

######### 图

##########  

######## 优先级区域回收方式

######### 维护一个优先级列表，根据设定的允许停顿时间，优先回收价值最大的Region

价值：回收所获得的空间大小以及回收所需时间的经验值

####### 细节问题

######## 跨Region引用问题

######### 每个Region维护一个记忆集，记录别的Region指向自己的指针

######## 与用户线程并发问题

######### 通过原始快照(SATB)算法修正用户程序导致的标志变动 

######### Region中两个TAMS指针指向GC时新分配对象的地址，不纳入回收

######## 可靠的停顿预测模型

######### 基于衰减均值理论

衰减均值比平均值更准确地代表“最近的”平均状态。

########## 记录GC每个步骤的成本，并分析平均值，标准偏差，置信度等

####### 基于标记-整理和标记-复制 

除并发标记外，其余阶段要停顿

######## 初始标记

######### 标记GC Roots的直接关联对象，并修改TAMS指针的值

######## 并发标记

######### 对堆中对象进行可达性分析

######## 最终标记

######### 处理并发标记阶段遗留的少量SATB记录

######## 筛选回收

######### 对每个Region的价值和成本排序，根据用户期望停顿时间制定回收计划

######### 决定回收Region将存活对象复制到空Region中，然后清除

######## 图

#########  

####### 与CMS收集器对比

######## 优点

######### 可指定最大停顿时间、分Region的内存布局、按收益动态确定回收集等

######### 不产生内存空间碎片

######## 缺点

######### 内存占用高

########## G1卡表复杂且每个Region一个，CMS卡表简单且只有一份

卡表用来处理跨代指针。

######### 额外负载高

########## G1要写前屏障和后屏障，CMS只写前屏障

######## 小内存应用用CMS，大内存应用用G1

内存为6～8GB之间。

##### 内存分配和回收策略

###### 对象优先在Eden分配

####### Eden区没有足够空间分配时，发起一次Minor GC

###### 大对象直接进入老年代

大对象指需要大量连续内存空间的对象，如很长的字符串及其数组。

####### 大对象容易导致明明还有不少内存却提前触发GC，以获取足够的连续空间

####### -XX: PretenureSizeThreshord

######## 大于设定值的对象直接分配在老年代，避免在Eden和Survivor之间来回复制

###### 长期存活的对象进入老年代

####### 虚拟机为每个对象定义一个对象年龄计数器

####### 对象在Eden区诞生，第一次Minor GC存活后进入Survivor，年龄为1

####### 在Survivor每熬过一次Minor GC年龄加1，到一定年龄后晋升到老年代

####### -XX：MaxTenuringThreshold

######## 设置对象晋升老年代的年龄阈值

###### 动态对象年龄判断

####### 不是永远要求年龄大于-XX : MaxTenuringThreshold才能进入老年代

####### 若Survivor中相同年龄所有对象大小总和大于该空间的一半，>=该年龄对象进入老年代

###### 空间分配担保

####### Minor GC前，老年代最大可用连续空间 > 新生代所有对象总空间？

######## 是

######### 这次Minor GC确保是安全的

######## 否

######### -XX:HandlePromotionFailure设置是否允许担保失败？

########## 是

########### 老年代最大可用连续空间 > 历次晋升老年代对象平均大小？

############ 是

############# 冒险Minor GC

############ 否

############# Full GC

########## 否

########### Full GC

#### 类加载机制

- JVM把类数据从Class文件加载到内存，经校验、转换解析、初始化形成Java类型

- 类型的加载、连接和初始化过程都在程序运行期间完成

##### 类的生命周期 

######  

为支持运行时绑定特性(动态绑定)，解析阶段在某种情况下可在初始化阶段之后开始。

###### 类的初始化时机

####### 主动引用

触发类初始化

######## 遇到new、getstatic、putstatic或invokestatic字节码指令

######### new实例化对象

######### 设置或读取类的静态字段

被final修饰、已在编译期把结果放入常量池的静态字段除外。

######### 调用类的静态方法

######## 对类进行反射调用 

######## 初始化时先初始化父类

接口仅在真正用到父接口时才初始化。

######## 虚拟机启动时，会先初始化要执行的主类（包含main()方法的）

######## 使用JDK 7的动态语言支持时

如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、 REF_putStatic、 REF_invokeStatic、 REF_newInvokeSpecial四种类型的方法句柄， 并且这个方法句柄对应的类没有进行过初始化， 则需要先触发其初始化。

######## 实现了有默认方法的接口，先初始化该接口

####### 被动引用

不触发类初始化

######## 通过子类引用父类的静态字段，子类不初始化

```
System.out.println(SubClass.value); // value字段在SuperClass中定义
```

######## 通过数组定义来引用类，此类不初始化

```
SuperClass[] sca = new SuperClass[10];
```

######## 不触发定义常量的类的初始化

常量会在编译阶段就存入调用类的常量池中。
```
System.out.println(ConstClass.HELLOWORLD);
```

##### 类加载的过程

包括加载、验证、准备、解析和初始化这5个阶段。


###### 加载

“加载”是“类加载”过程的一个阶段，不要混淆。

####### 三个动作

######## 全限定名 --> 定义此类的二进制字节流

######## 字节流所代表的静态存储结构 --> 方法区的运行时数据结构

######## 内存中生成该类Class对象 --> 方法区该类的数据访问入口

####### 二进制字节流来源

######## Class文件

######### javac编译

######## ZIP --> JAR、EAR、WAR格式的基础

######## 网络

######### Web Applet

######## 运行时计算

######### 动态代理技术

######## 其他文件

######### JSP应用

######## 数据库

######## 加密文件

######### 防Class文件被反编译

###### 验证

####### 确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

###### 准备

####### 为类变量（静态变量）分配内存并设置初始值

######## 分配内存

######### 分配内存的不包括实例变量

实例变量会在对象实例化时随对象分配到Java堆。

######### 使用方法区内存

JDK 8后，类变量随Class对象一起存放在Java堆中。

######## 初始值

######### 通常为数据类型的零值

```
public static int value = 123;
```
value在准备阶段后的初始值为0，而不是123。

######### 若类变量是常量，初始值不是零值

```
public static final int value = 123;
```
常量value在准备阶段后的初始值为123，而不是0。

###### 解析

####### 将常量池内的符号引用替换为直接引用的过程

对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行解析，得到类或者字段、方法在内存中的指针或者偏移量。

###### 初始化

####### 初始化阶段就是执行类构造器<clinit>()方法的过程

####### <clinit>()

<clinit>()不是Java代码中直接编写的方法， 是Javac编译器的自动生成物。

######## 由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生

编译器收集顺序由语句在源文件中出现顺序决定

######## 静态语句块中只能访问在其之前定义的变量，之后定义的只能赋值，不能访问

```
public class Test {
	static {
		i = 0; // 给变量赋值可以正常编译通过
		System.out.print(i); // 这句编译器会提示“非法向前引用”
	}
    static int i = 1;
}
```

######## 父类<clinit>()先于子类<clinit>()执行 --> 父类的静态语句块先于子类的变量赋值

```
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

######## 若类中无静态语句块和变量赋值操作，则不生成<clinit>()

接口中不可使用静态语句块，但可有变量赋值操作，故可生成<clinit>()

######## 执行接口的<clinit>()无需先执行父接口的<clinit>()

因为仅当父接口中变量被使用时才会初始化。

######## 多个线程同时初始化一个类，只有一个线程执行<clinit>()，其他线程阻塞

那条线程退出<clinit>()后，其他线程不再进入<clinit>()。同一类加载器下，一个类型只会初始化一次。

##### 类加载器

实现“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作的代码叫“类加载器”。

###### 类与类加载器

####### 两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。

这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。

```

Object obj = myLoader.loadClass("org.fenixsoft.classloading.ClassLoaderTest").newInstance();
System.out.println(obj instanceof org.fenixsoft.classloading.ClassLoaderTest);
}  // false
```
第一个ClassLoaderTest由自定义加载类加载，第二个ClassLoaderTest由JVM应用程序类加载器加载，虽然来自同一Class文件，但是是两个独立的类。

###### 双亲委派模型

####### JVM角度

######## 启动类加载器

######### C++语言实现，是虚拟机自身一部分

######## 其他类加载器

######### Java语言实现，独立于虚拟机，继承自抽象类java.lang.ClassLoader

####### Java开发人员角度

######## 启动类加载器

- 无法被Java程序直接引用；
- 用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理， 那直接使用null代替即可。

######### <JAVA_HOME>\lib目录

######### -Xbootclasspath参数所指定路径

######## 扩展类加载器

- 由sun.misc.Launcher$ExtClassLoader实现的。
- 开发者可以直接使用扩展类加载器。

######### <JAVA_HOME>\lib\ext目录

######### java.ext.dirs系统变量所指定路径

######## 应用程序类加载器

- 由sun.misc.Launcher$AppClassLoader来实现。
- 开发者可以在代码中直接使用。
- 若程序中无自定义类加载器，默认为此类加载器。

######### 用户类路径（ClassPath）上所有的类库

######## 自定义类加载器

######### 增加除磁盘之外的Class文件来源

######### 通过类加载器实现类的隔离、重载等功能

####### 工作过程

######## 加载一个类，首先请求委托父加载器去完成

因此所有加载请求都应该传递到最顶层的启动类加载器。

######## 父加载器无法加载时，子加载器才尝试加载

####### 好处

######## Java 类随着它的类加载器一起具有一种带有优先级的层次关系

例如类java.lang.Object， 它存放在rt.jar之中， 无论哪一个类加载器要加载这个类， 最终都是委派给处于模型最顶端的启动类加载器进行加载， 因此Object类在程序的各种类加载器环境中都能够保证是同一个类。 

####### 实现

######## java.lang.ClassLoader的loadClass()方法

```
public abstract class ClassLoader {
    // 用于委派的父类加载器
    private final ClassLoader parent;

    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return loadClass(name, false);
    }
    
    protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoudException
    {
        // 首先，检查请求的类是否已经被加载过了
        Class c = findLoadedClass(name);
        // 若没有则调用父加载器的loadClass()方法
        if (c == null) {
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // 若父加载器为空则默认启动类加载器作父加载器
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 如果父类加载器抛出ClassNotFoundException
                // 说明父类加载器无法完成加载请求
            }
            if (c == null) {
                // 在父类加载器无法完成加载时
                // 再调用本身的findClass方法来进行类加载
                c = findClass(name);
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

####### 图 

除了顶层的启动类加载器外， 其余的类加载器都应有自己的父类加载器。 通常使用组合（Composition） 关系来复用父加载器的代码，而不是以继承（Inheritance） 的关系来实现的。

#### 高效并发

##### Java内存模型（JMM）

###### 内存

####### 主内存

######## 所有变量

####### 工作内存

######## 线程使用的变量

######## 主内存副本拷贝

###### volatile

####### 保证对所有线程的可见性

######## volatile变量在各个线程中的工作内存中不存在一致性问题

######## 运算并非原子操作，因此volatile变量的运算在并发下是不安全的

####### 禁止指令重排序优化

###### 原子性、可见性与有序性

####### 原子性（Atomicity）

######## read、load、assign、use、store、write使得基本数据类型的访问读写具备原子性

######## lock和unlock操作使得synchronized块之间的操作具备原子性

####### 可见性（Visibility）

定义：一个线程修改共享变量的值，其他线程能够立即得知这个修改。

实现方式：新值同步回主内存，变量读取前从主内存刷新。

######## volatile

######### 保证新值立即同步到主内存，变量使用前立即从主内存刷新

######## synchronized

######### unlock前把变量同步回主内存

######## final

######### final变量一旦初始化，其他线程即可访问

####### 有序性（Ordering）

定义：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的。因为指令重排序不会影响单线程执行，却影响多线程并发执行。

######## volatile

######### 禁止指令重排序

######## synchronized

######### 一个变量同一时刻只允许一条线程对其lock

###### 先行发生原则

“→”表示先行发生于

####### 程序次序规则

######## 一个线程内，写在前面的操作 → 写在后面的操作

####### 管道锁定规则

######## 同一锁，unlock操作 → lock操作

####### volatile变量规则

######## 对volatile变量，写操作 → 读操作

####### 线程启动规则

######## Thread.start() → 线程的所有操作 

####### 线程终止规则

######## 线程的所有操作 →  Thread.join()

####### 线程中断规则

######## Thread.interrupt() → Thread.interrupted()

####### 对象终结规则

######## 一个对象，初始化完成 → finalize()开始

####### 传递性

######## A操作 → B操作，B操作 → C操作，则A操作 → C操作

###### 协程

- 一个线程含多个协程；
- 用户态，函数实现切换；
- 串行执行。

####### 背景

######## 每个请求执行时间很短、 数量很多时，切换开销可能接近计算开销，严重浪费

######## 内核线程调度从用户态转换到内核态，需要响应中断、保护和恢复现场的成本开销

####### 纤程（FIber）

######## 执行过程

######### 维护执行现场，保护、恢复上下文状态

######## 调度器

######### 负责编排所有要执行代码的顺序

######## 用户可选择自行控制以上的一个或多个

####### Quasar协程库

######## 不依赖JVM

######## 在字节码层面对调用函数中所有局部变量进行保存和恢复。

##### 线程安全

多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。

###### 不可变

不可变的对象一定是线程安全的，不需要再采取任何线程安全保障措施。


####### final修饰的基本数据类型

####### 带有状态的变量都声明为final的对象

####### java.lang.String类

####### 枚举类型

####### java.lang.Number的部分子类

######## Long和Double等数值包装类型

######## BigInteger和BigDecimal等大数据类型

###### 实现方法

####### 互斥同步

共享数据同一时刻只被一个线程使用

######## synchronized

######### monitorenter

########## 锁计数器加1

######### monitorexit

########## 锁计数器减1

######## ReentrantLock

######### 等待可中断

########## 持有锁的线程长期不释放锁时，正等待的线程可放弃等待，改做其他事

######### 公平锁

########## 多个线程等待同一锁时，按照申请锁的时间顺序获得锁

######### 锁绑定多个条件

########## ReentrantLock对象可以同时绑定多个Condition对象

######## 问题

######### 线程阻塞、唤醒→性能降低

######### 悲观的并发策略

####### 非阻塞同步

依靠硬件保证从语义看需要多次操作的行为只通过一条处理器指令就能完成。

######## 乐观的并发策略

######## CAS(Compare-and-Swap)原子操作

######### 指令执行时，当且仅当内存地址V的值等于旧预期值A，才用新值B更新V的值

######### AtomicInteger的compareAndSet()和getAndIncrement()等使用了Unsafe类的CAS操作

######### “ABA”问题

####### 无同步方案

如果一个方法本不涉及共享数据，那么无需任何同步措施保证正确性。

######## 可重入代码

可在代码执行的任何时刻中断它，去执行另一段代码，返回控制权后，原程序不会出错。

######### 可重入代码 => 线程安全

######### 如果一个方法，输入相同的数据，都返回相同的结果，则满足可重入性

######## 线程本地存储

######### ThreadLock类

########## 每个Thread对象有个ThreadLocalMap对象

########### 键：ThreadLocal.threadLocalHashCode

########### 值：本地变量

###### 锁优化

####### 自旋锁

挂起线程和恢复线程需要转入内核态中完成，影响性能。当共享数据锁定时间很短时，让线程执行一个忙循环（自旋）。

######## 避免了线程切换的开销，但占用处理器时间

######## 锁占用时间很短时，自旋等待效果好，反之，则浪费处理器时间

######## 自旋必须限定次数，超过次数则挂起，默认10次

######## 自适应自旋锁

自旋时间不固定，由上一次同一锁上的自旋时间及锁拥有者的状态决定

####### 锁消除

对于被检测出不可能存在竞争的共享数据的锁进行消除。

######## 堆上所有数据不会逃逸，其他线程无法访问，则无需同步加锁。

####### 锁粗化

######## 如果一系列连续操作对同一对象反复加锁和解锁，频繁互斥同步会导致不必要的性能损耗。

######## 虚拟机若探测到一串零碎操作对同一对象加锁，将会把加锁同步范围扩展到整个操作序列。

####### 轻量级锁

先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。

######## 如果没有竞争，使用CAS操作避免了互斥量的开销。

######## 如果存在竞争，比重量级锁增加了CAS操作，因此更慢。

######## 不是用来代替重量级锁，而是在没竞争时，减少重量级锁互斥量产生的性能损耗。

####### 偏向锁

偏向第一次获取锁对象的线程，之后该线程每次进入该锁相关同步块时，不再进行同步操作。

######## 在无竞争时把整个同步都消除掉，连CAS操作都不需要。

### 并发

- [Java 并发](https://cyc2018.github.io/CS-Notes/#/notes/Java%20并发)

#### 线程生命周期

#####  

#### 死锁

##### 避免死锁

###### 破坏互斥条件

###### 破坏请求与保持条件

####### 一次性申请所有资源

###### 破坏不剥夺条件

####### 申请不到，主动释放已占有资源

###### 破坏循环等待条件

####### 顺序申请资源，反序释放

#### synchronized

保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

##### 了解

###### 早期版本，重量级锁，用户态到内核态，效率低

###### JDK1.6后，锁优化

##### 使用方法

###### 修饰实例方法

####### 对象加锁

###### 修饰静态方法

####### 类加锁

###### 修饰代码块 

####### 对象或类加锁

##### 底层原理

###### 同步块

####### 开头monitorenter，结尾monitorexit 

####### 锁计数器+1，-1

###### 同步方法

####### ACC_SYNCHRONIZED 标识

##### 锁优化

###### 自旋锁

####### 共享数据的锁定状态很短的场景

####### 避免阻塞减少开销，但忙循环占CPU

###### 锁消除

####### 不可能存在竞争

###### 锁粗化

###### 轻量级锁

####### 先CAS，失败后互斥量

###### 偏向锁

####### 第一次获得锁的线程，其他线程没获取该锁，后续无需同步

##### 与Reentrantlock的区别

###### 两者都是可重入锁

###### synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API

###### ReentrantLock高级功能

####### 等待可中断

####### 公平锁

####### 可绑定多个Condition对象，选择性通知

### 容器

- [Java 容器](https://cyc2018.github.io/CS-Notes/#/notes/Java%20容器)

#### ArrayList

##### RandomAccess接口 -> 快速随机访问

##### 扩容

###### 默认容量10，未添加元素前数组为空

###### 1.5倍

```
oldCapacity + (oldCapacity >> 1)
```

###### Arrays.copyOf()复制到新数组

##### 插入删除元素

###### System.arraycopy()移动元素

##### 序列化

###### transient Object[] elementData;

##### Fail-Fast

###### modCount

####### 记录 ArrayList 结构发生变化的次数

###### 序列化或者迭代

####### ConcurrentModificationException

#### HashMap

##### 存储结构

###### JDK 1.7

####### Entry数组+链表（拉链法）

###### JDK 1.8

####### 数组+链表+红黑树

######## 数组长度>=64，链表长度>=8时，转红黑树

##### 扩容

###### 默认容量16

###### loadFactor 0.75

###### resize方法

####### 重新计算hash值，遍历所有元素

####### 2倍

##### 桶下标

###### 取模 (n - 1) & hash

###### 扰动函数hash

####### 减少碰撞

##### put方法

###### JDK1.7

####### 头插法

###### JDK1.8

####### 判断头节点，插入尾部

#### ConcurrentHashMap

##### 存储结构

###### JDK 1.7

####### Segment 数组 + HashEntry 数组 + 链表

###### JDK 1.8

####### Node 数组 + 链表 + 红黑树

##### 线程安全

###### JDK 1.7

####### 分段锁 (Segment)

####### ReentrantLock

###### JDK 1.8

####### 锁定链表或红黑树的首节点

#######  synchronized + CAS

#### LinkedHashMap

##### 继承自 HashMap，双向链表维护插入或LRU顺序

##### afterNodeAccess()

###### accessOrder == true，访问节点移至链表尾部

##### afterNodeInsertion()

###### removeEldestEntry() == true, 插入后移除链表首节点

##### LRU 缓存

```

class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private static final int MAX_ENTRIES = 3;

    protected boolean removeEldestEntry(Map.Entry eldest) {
        return size() > MAX_ENTRIES;
    }

    LRUCache() {
        super(MAX_ENTRIES, 0.75f, true);
    }
}
```

###### 设定MAX_ENTRIES

###### accessOrder设为true

###### 覆盖removeEldestEntry()方法返回true

### I/O

- [Java IO](https://cyc2018.github.io/CS-Notes/#/notes/Java%20IO)

#### BIO

同步阻塞I/O模式

##### 传统BIO

###### 一旦建立通信，不能接受其他客户端请求

###### 同时处理多个客户端请求，就必须使用多线程

###### 线程创建和销毁成本高、并发访问量增加可能会导致线程堆栈溢出

##### 伪异步IO

###### 线程池机制

###### 防止由于海量并发接入导致线程耗尽

#### NIO

同步非阻塞的I/O模型

##### Channel (通道)

###### 通道是双向的，可读也可写，而流的读写是单向的

##### Buffer(缓冲区)

###### IO 面向流，而 NIO 面向缓冲区

###### 状态变量

####### capacity

######## 最大容量

####### position

######## 已读写字节数

####### limit

######## 可读写字节数

##### Selector (选择器)

###### 轮询监听多个通道，因此需配置套接字通道为非阻塞

######  阻塞在select()监听事件到达

#### AIO

### Web

- [69 道 Spring 面试题和答案](http://ifeve.com/spring-interview-questions-and-answers/)
- [Spring 面试题](https://github.com/Homiss/Java-interview-questions/blob/master/%E6%A1%86%E6%9E%B6/Spring%20%E9%9D%A2%E8%AF%95%E9%A2%98.md)
- [Spring 面试问答 Top 25](http://www.importnew.com/15851.html)
- [Spring 总结以及在面试中的一些问题.](https://www.cnblogs.com/wang-meng/p/5701982.html)


#### Spring Core

##### Spring IOC

###### 概念

####### 控制反转（IoC），一种面向对象编程的设计思想

####### 依赖注入（DI），是IoC思想的实现方式

####### IoC容器，是实现依赖注入的关键，本质上是一个工厂

##### Spring AOP

##### Spring Bean

###### @Component和@Bean

####### @Component

######## 作用于类

######## 通过类路径扫描，并自动装配到Spring容器中

####### @Bean

######## 作用于方法

######## 方法中定义并返回bean

######## 用于将第三方库中的类装配到Spring容器中

###### Bean注解

####### @Autowired

######## 自动注入bean

####### @Component

######## 通用bean注解

####### @Repository

######## 对应持久层（Dao）层

####### @Service

######## 对应服务层

####### @Controller

######## 对应Spring MVC 控制层

###### Bean生命周期

###### Bean的作用域(scope)

####### singleton

######## 单例模式，默认值

####### prototype

######## 每次调用getBean()，返回一个新实例

####### request

######## 每个HTTP请求都创建一个新Bean，仅适用于WebApplicationContent环境

####### session

######## 每个HTTP Session对应一个新Bean，仅适用于WebApplicationContext环境

####### globalSession

######## 用于Protlet应用环境，仅适用于WebApplicationContext环境

#### Spring Data Access

##### Spring 事务管理

###### Spring事务管理接口

####### PlatformTransactionManager 事务管理器

######## getTransaction

根据指定的传播行为，返回当前活动的事务或创建一个新事务。

######## commit

######## rollback

####### TransactionDefinition 定义事务属性

######## 隔离级别

######## 传播行为

当前事务方法被另一事务方法调用是，指定事务如何传播。


######### PROPAGATION_REQUIRED

如果当前存在事务，则加入该事务；否则，则创建一个新的事务。

######### PROPAGATION_REQUIRES_NEW

创建一个新的事务，如果当前存在事务，则把当前事务挂起。

######### PROPAGATION_NESTED

如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；否则，则等价于REQUIRED。

######## 事务超时

一个事务允许执行的最长时间

######## 是否只读

对事务资源是否只执行只读操作

######## 回滚规则

定义哪些异常导致事务回滚

####### TransactionStatus 记录事务的状态

###### Spring事务管理方式

####### 声明式事务

######## 基于AspectJ

######## 基于 @Transactional 注解

####### 编程式事务

######## 通过 TransactionTemplate 管理事务

业务方法较复杂，只管理中间小部分事务时使用。

##### MyBatis

#### Web Servlet

##### servlet

###### 生命周期

####### init() 初始化

#######  service()处理客户端请求

####### destroy()释放资源 

##### SpringMVC

###### Controller单例与线程安全

####### 不定义成员变量

####### @Scope(“prototype”)设为多例

####### 使用ThreadLocal变量

###### 图

#######  

## 系统设计

<!--Note-->
#### 资料

- 《大型网站技术架构》
- 《从 Paxos 到 Zookeeper》
- 《微服务设计》
<!--/Note-->

### 基础

- [系统设计基础](https://cyc2018.github.io/CS-Notes/#/notes/系统设计基础)

#### 性能

#### 伸缩性

#### 扩展性

#### 可用性

#### 安全性

### 分布式

- [分布式](https://cyc2018.github.io/CS-Notes/#/notes/分布式)

#### 分布式事务

#### CAP

#### BASE

#### Paxos

#### Raft

#### 分布式锁

#### 分布式 ID

### 集群

- [集群](https://cyc2018.github.io/CS-Notes/#/notes/集群)

#### 负载均衡

#### Session 管理

### 缓存

- [缓存](https://cyc2018.github.io/CS-Notes/#/notes/缓存)

#### 缓存特征

#### LRU

#### 缓存位置

#### CDN

#### 缓存问题

#### 一致性哈希

### 攻击技术

- [攻击技术](https://cyc2018.github.io/CS-Notes/#/notes/攻击技术)

#### XSS

#### CSRF

#### SQL 注入

#### DDoS

### 消息队列

- [消息队列](https://cyc2018.github.io/CS-Notes/#/notes/消息队列)

#### 消息模型

#### 使用场景

#### 可靠性

### 高并发系统

#### 秒杀系统

#### 限流算法

#### 服务熔断与服务降级

### 服务拆分

#### 幂等性

#### 远程服务访问方法

#### 微服务

#### SOA

### 系统设计

#### Web 页面请求过程

#### 二维码登录

#### TinyURL

#### KV 存储系统

#### 搜索引擎

## C++

## 中间件

### RabbitMQ

### ZooKeeper

### Dubbo

### Nginx

## 其它知识

### 新技术

### 开源项目

## 项目

### Community

#### 登录模块

##### 发送邮件

##### 会话管理

###### Cookie

####### 创建Cookie，一个键值对

######## 设置生效范围、相应时间

######### Response Headers 的 Set-Cookie

########## Request Headers 的 Cookie

##### 显示登录信息

###### 配置拦截器

####### preHandle : 检查ticket，将user存入ThreadLocal 

######## postHandle : 将user存入modelAndView

######### afterCompletion : 清除ThreadLocal

##### 账户设置

###### MultipartFile中提取文件重命名

####### MultipartFile的transferTo(File)存储文件

######## 更新用户头像路径

##### 检查登录状态

###### 创建LoginRequired注解类

####### 登录才能访问的方法加上注解

######## 拦截器preHandle方法中检查登录状态和LoginRequired注解

#### 核心模块

##### 过滤敏感词

##### 统一异常处理

## 面试相关

### 简历

### 投递
